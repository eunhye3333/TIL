# 리눅스 시스템의 이해

# 2.1 리눅스와 하드웨어

## 2.1.1 하드웨어의 이해

### 리눅스 설치를 위한 하드웨어 정보 파악

1. CPU

   리눅스 시스템에서 CPU 관련 정보를 확인하는 방법

   - 관련 파일에서 확인하는 방법

     ```bash
     cat /proc/cpuinfo
     ```

   - 명령어를 이용하는 방법

     ```bash
     lscpu
     ```

2. 메모리(RAM)

   메모리의 용량은 하드 디스크의 일부 공간을 램처럼 사용하는 스왑 파티션 설정과 관련 있기 떄문에 꼭 확인해야 함

   대용량 메모리를 사용하기 위해서는 CPU의 지원 여부 확인 후 확장 페이징 기법을 지원하는 Kernel-PAE(Physical Address Extension) 커널로 대체하여 사용 가능 (하지만 한 프로세스가 물리적으로 4GB 이상의 메모리를 요구하는 경우에는 사용 불가능)

3. 하드 디스크 드라이브

   CPU나 메모리는 리눅스를 설치하면 별도로 설정할 일이 없으나 하드 디스크 드라이브의 경우 파티션 변경이나 설정, 스왑 설정 등으로 인해 변경할 일이 발생할 수 있음

   리눅스는 모든 장치를 파일화하여 관리하는데 하드 디스크 인터페이스에 따라 파일명이 달라짐

   - IDE, ATA: /dev/hda, /dev/hdb 등
   - SCSI, S-ATA, USB, SSD: /dev/sda, /dev/sdb 등’

4. 모니터와 비디오 어댑터

5. 네트워크 인터페이스

   리눅스는 네트워크 환경을 기반으로 사용하기 때문에 네트워크 인터페이스 설정이 필수

6. 키보드 및 마우스

7. CD-ROM 및 DVD-ROM

   하드 디스크와 마찬가지로 파일로 관리됨

   - IDC, ATA: /dev/hdx
   - SCSI, S-ATA: /dev/sdx

   최근 리눅스 배포판에서는 /dev/cdrom, /dev/dvd라는 이름으로 심볼릭 링크 파일을 생성해 제공

8. 기타 하드웨어

   사운드카드, 프린터 등

<br>

## 2.1.2 하드웨어의 선택

### RAID

RAID(Redundant Array of Independent[또는 inexpensive] Disks): 여러 개의 하드디스크가 있을 때 동일한 데이터를 다른 위치에 중복해서 저장하는 방법으로 입출력 작업이 균형을 이루게 하여 성능을 향상시킴

운영체제에서 하나의 RAID는 논리적으로 하나의 디스크로 인식하여 처리

하드웨어 수준의 RAID: 핫스왑, 베이

<br>

RAID에서 사용하는 기술

- 스트라이핑(Striping)

  연속된 데이터를 여러 개의 디스크에 라운드로빈 방식으로 기록하는 기술

  프로세서가 하나의 디스크에서 읽어 들이는 것보다 더 빠르게 데이터를 읽거나 쓸 수 있다면 매우 유용함 (서로 겹쳐서 읽거나 쓸 수 있도록 설계된 네 개의 드라이브가 있는 경우 하나의 섹터를 읽을 시간에 네 개의 섹터를 동시에 읽을 수 있음)

- 미러링(Mirroring)

  디스크에 에러 발생 시 데이터의 손실을 막기 위해 추가적으로 하나 이상의 장치에 중복 저장하는 기술

  결함 허용이라고도 부르며 소프트웨어적으로도 구현 가능

<br>

RAID의 종류

- RAID-0

  스트라이핑 기술을 사용하여 빠른 입출력 속도 제공 데이터를 중복이나 패리티 없이 디스크에 분산하여 기록 처리 속도는 빠르나 데이터 복구 불가능

- RAID-1

  미러링 기술을 사용하여 두 개의 디스크에 데이터를 동일하게 기록 읽기 성능은 향상되나 쓰기 성능은 단일 디스크와 같음 데이터 복구 능력은 탁월하지만 디스크 낭비가 심함

- RAID-2

  디스크들은 스트라이핑 기술을 사용하여 구성하고 디스크의 에러 감지, 수정을 위해 ECC(Error Check & Correction) 정보를 사용

- RAID-3

  스트라이핑 기술을 사용하여 디스크 구성 패리티 정보를 저장하기 위해 별도로 하나의 디스크 사용 입출력 작업이 동시에 모든 디스크에 대해 이루어지므로 입출력을 겹치게 할 수는 없음 대형 레코드가 많은 시스템에서 사용

- RAID-4

  블록 형태의 스트라이핑 기술을 사용하여 디스크 구성 단일 디스크로부터 레코드를 읽을 수 있고 데이터를 읽을 때 중첩 입출력의 장점이 있음 쓰기 작업의 경우 패리티 연산을 해야 하고 패리티 디스크에 저장해야 하기 때문에 입출력 중첩 불가능, 병목현상 발생 가능

- RAID-5

  패리티 정보를 이용하여 하나의 디스크가 고장난 경우에도 사용이 가능한 구성 방식 최소 3개의 디스크로 구성 패리티 정보는 별도의 디스크를 사용하지 않고 분산하여 기록하지만 데이터를 중복 저장하지는 않기 때문에 가장 보편적 디스크에 쓰기 제한 주소를 지정하므로 모든 읽기 및 쓰기 중첩 가능 작고 랜덤한 입출력이 많은 경우 더 나은 성능

- RAID-6

  RAID-5와 비슷하지만 디스크에 2차 패리티 구성을 포함하여 높은 고장대비 능력 발휘 RAID-5의 경우 1개의 디스크 오류에만 대처가 가능하나 RAID-6은 2개의 디스크 오류에도 데이터를 읽을 수 있음 공간 효율성과 처리 속도는 떨어지나 신뢰도는 향상

- RAID-7

  하드웨어 컨트롤러에 내장되어 있는 실시간 운영체제를 사용하여 구성하는 방식

- RAID 0+1

  디스크 2개를 RAID-0의 스트라이핑 기술로 구성하고 다시 RAID-1의 미러링으로 구성하는 방식 최소 4개의 디스크 필요

- RAID-10

  RAID 0+1의 반대 개념으로 디스크 2개를 먼저 미러링으로 구성하고 다시 스트라이핑하는 방식

- RAID-53

  RAID-3 방식에 별도로 스트라이프 어레이를 구성하는 방식

  RAID-3보다 높은 성능을 제공하나 구성 비용이 많이 듦

<br>

### LVM(Logical Volume Manager)

LVM: 여러 디스크를 합쳐서 하나의 디스크인 것처럼 만들거나 하나의 디스크를 여러 개인 것처럼 분할함

LVM 구성도와 관련 용어

- 물리적 볼륨(PV): 실제 디스크에 물리적으로 분할한 파티션, LVM에서는 물리적 볼륨을 하나의 구성원으로 받아들이는 형식으로 진행
- 볼륨 그룹(VG): 물리적 볼륨이 모여서 생성하는 덩어리(LVM에서 구성되는 단위인 PE가 모여서 생성되는 덩어리)
- 논리적 볼륨(LV): VG에서 사용자가 필요한만큼 할당하여 만들어지는 공간, 디스크의 구조와 상관없이 원하는 크기로 생성 가
- 물리적 확장(PE): PV에서 나누어 사용하는 블록 같은 영역으로 1PE가 4MB 정도씩 할당됨

<br>

# 2.2 리눅스의 구조

## 2.2.1 부트 매니저

부트 매니저(부트 로더): 부팅을 도와주는 역할을 하는 프로그램으로 하나의 컴퓨터에 여러 운영체제가 설치되어 있을 경우 선택하여 부팅할 수 있게 함

하드 디스크의 맨 앞쪽 영역인 MBR(Master Boot Record)에 설치됨

MBR: 부트 섹터로 디스크의 첫번째(0번) 섹터에 해당, 크기는 512 byte

<br>

리눅스의 대표적 부트 매니저

- LILO(Linux Loader): 리눅스용 부트 매니저 프로그램으로 파일 시스템에 구애받지 않고 플로피 디스크와 하드 디스크를 이용한 부팅 지원

  8GB 영역이 넘어가는 곳에 리눅스가 설치되어 있으면 부팅을 못하는 경우 발생

  환경 설정 파일 수정 후 반드시 lilo 명령을 수행해야 하는 불편함

- GRUB(Grand Unified BootLoader)

<br>

### GRUB

GNU에서 프로젝트에서 만든 부트로더로 LILO에 비해 다양한 파일 시스템을 지원하고 동적인 부팅 지원

- 부트 화면

  메뉴 목록 형식으로 제공되며 e나 c를 누르면 커널 인자값 조정을 통한 부팅 환경 수정 가능

- 부팅 모드

  - 편집 모드: e 클릭 (부팅 방법: Ctrl + X)
  - 명령 프롬프트 모드: c 클릭 (부팅 방법: boot 입력)

- 환경 설정 파일

  /boot/grub2/grub.cfg 파일에서 환경 설정 가능

  심볼릭 링크 파일인 /etc/grub2.cfg도 사용 가능

  셸 스크립트 형태이며 /etc/grub.d 내부 파일과 /etc/default/grub 파일을 참고하여 동작

  GRUB 2 버전부터는 환경 설정 파일 수정 후 `grub-mkconfig` 명령어 실행해야 함

  <br>

  주요 설정

  - GRUB_TIMEOUT=5

    GRUB 부트 화면에서 대기하는 시간을 초 단위로 지정

  - GRUB_DISTRIBUTOR=”$(sed ‘s, release .*$,,g’ /etc/system-release)”

    GRUB 부트 화면에서 각 엔트리 앞에 보여질 리눅스 배포판 이름 추출 시 사용

  - GRUB_DEFAULT=saved

    기본적으로 부팅할 모드를 선택하며 일반적으로 0 이상 정수값 입력 saved는 기본 메뉴 목록이 GRUB-SAFEDEFAULT 또는 grub-set-default에 의해 저장

  - GRUB_DISABLE_SUBMENU=true

    false인 경우 grub-mkconfig에서 버전 번호가 가장 높은 커널을 최상위 메뉴 항목으로 생성하고 다른 모드의 항목을 하위메뉴로 생성 true인 경우 하위 메뉴 생성하지 않음

  - GRUB_TERMINAL_OUTPUT=”console”

    GRUB이 출력되는 터미널 장치 설정

  - GRUB_CMDLINE_LINUX=”crashkernel=auto rhgb quiet”

    커널 인자값 지정

  - GRUB_DISABLE_RECOVERY=”true”

    부트 메뉴 엔트리에 복구 모드를 표시할 것인지 지정

- 관련 명령어(grub2-mkconfig)

  GRUB 환경 설정 파일 생성 명령으로 환경 설정 파일 변경 후에는 반드시 실행

  ```bash
  grub2-mkconfig [-o 파일명]
  ```

  | 옵션 | 설명                                                |
  | ---- | --------------------------------------------------- |
  | -o   | GRUB의 환경 설정 파일 생성 시 지정 (—output=파일명) |

<br>

### GRUB의 활용

- root 패스워드 분실

  응급 복구 모드에서 재설정 가능

  응급 복구 모드 접근 절차

  1. 시스템을 재부팅하여 GRUB 부트 메뉴가 나타나도록 함

  2. 기본 부트 엔트리에서 e를 눌러 커널 인자값을 수정할 수 있는 편집 상태로 진입

  3. 커널 인자값이 있는 줄의 맨 마지막 부분으로 이동

  4. 커널 인자값인 ‘ro rhgb quite LANG=ko_KR, UTF-8’을 지우고 ‘rw init=/bin/sh’ 입력

     USB 키보드를 사용하거나 가상 게스트인 경우 init=/bin/sh 설정으로 변경되지 않을 수 있음 해당 경우에는 init=/bin/sh 대신 rb.break로 설정

  5. Ctrl + X로 부팅 진행

  6. passwd 명령으로 패스워드 변경

  7. SELinux를 사용하는 경우 라벨 변경 명령 실행

     ```bash
     touch /.autorelabel
     ```

     SELinux: 보안 강화 리눅스 가상 디렉터리에서 파일을 수정하거나 정보를 변경하는 경우 실제 부팅 시에 레이블 정보가 저장되지 않은 채 부팅이 됨 따라서 라벨 변경 명령을 실행해 주어야 정상 변경 가능

     만약 부팅되지 않는 경우에는 SELinux 설정 변경

     ```bash
     vi /etc/sysconfig/selinux
     
     # SELinux=enforcing -> SELinux=disabled
     ```

  8. 시스템 재부팅

     ```bash
     exec /sbin/init
     ```

- GRUB 패스워드 설정

  root 패스워드를 임의로 변경하지 못하도록 응급 복구 모드 패스워드 설정

  1. vi나 gedit를 이용해 /etc/grub.d/00_header 파일을 열어 GRUB 사용자 및 패스워드 설정

     ```bash
     vi /etc/grub.d/00_header
     
     # 해당 파일 맨 아래에 다음 내용 추가
     cat <<EOF
     set superusers="유저아이디"
     password 유저아이디 패스워드
     EOF
     ```

  2. 다음 명령 실행

     ```bash
     grub2-mkconfig -o /boot/grub2/grub.cfg
     ```

  3. 재부팅

- 콘솔 모드의 터미널 해상도 변경

  /etc/default/grub 파일의 GRUB_CMDLINE_LINUX 항목 뒷부분에 ‘vga=값’ 추가

  <br>

  [해상도 조정을 위한 VGA 코드값]

  |       | 640*480 | 800*600 | 1024*768 | 1280*1024 | 1600*1200 |
  | ----- | ------- | ------- | -------- | --------- | --------- |
  | 8bit  | 769     | 771     | 773      | 775       | 796       |
  | 16bit | 785     | 788     | 791      | 794       | 798       |
  | 24bit | 786     | 789     | 792      | 795       | 799       |

- 네트워크 어댑터 이름 변경

  네트워크 어댑터 이름을 이전 형식(eth0, eth1 등)으로 변경 가능

  /etc/default/grub 파일에서 GRUB_CMDLINE_LINUX 항목 뒷부분에 ‘net.ifnames=0’ 추가

<br>

## 2.2.2 리눅스 디렉터리 구조 및 역할

### 디렉터리 개요

디렉터리: 파일을 보관하는 곳

리눅스는 최상위 루트 디렉터리를 중심으로 하위에 다수 디렉터리가 존재하는 트리 구조

<br>

### 디렉터리 종류와 특징

- / : 최상위에 있는 디렉터리 (루트(root) 디렉터리)
- /bin: binary의 약자로 실행 파일(명령어)이 들어 있는 디렉터리, 보통 PATH가 설정되어 있음
- /boot: 시스템 부팅 시 필요한 파일이 들어 있는 디렉터리
- /dev: 실제로 존재하는 물리적인 장치(하드 디스크 등)를 파일화하여 관리하는 디렉터리
- /etc: 시스템 환경 설정 파일 및 부팅과 관련된 스크립트 파일이 있는 디렉터리
- /home: 개인 사용자들이 만들어서 사용할 수 있는 홈 디렉터리
- /lib: 각종 라이브러리가 저장된 디렉터리 (커널 모듈도 해당 디렉터리 내부에 있음)
- /lib64: 64비트 기반의 라이브러리 관련 디렉터리
- /mnt: 마운트 시 포인터가 되는 디렉터리
- /opt: 응용 프로그램의 설치를 위해 사용되는 디렉터리
- /proc: 가상 파일 시스템으로 시스템에서 운영되고 있는 정보를 담고 있음
- /root: 시스템 관리자의 홈 디렉터리
- /sbin: 시스템 관리에 대한 명령어들이 들어 있는 디렉터리로 주로 root 사용자가 사용함
- /tmp: 임시 저장 디렉터리로 임시로 생성되는 파일 저장
- /usr: 시스템 운영에 필요한 명령, 응용 프로그램들이 위치하는 디렉터리
- /var: 가변적인 데이터를 저장하는 디렉터리
- /media: 이동식 장치의 마운트를 위해 제공되는 디렉터리
- /srv: 사이트에서 생성되는 데이터를 저장하는 디렉터리, 앞으로 /var의 역할을 대체할 가능성 있음
- /sys: 2.6 커널에서 사용되는 가상 파일 시스템인 sysfs에서 사용하는 디렉터리로 USB처럼 hot plug 하드웨어 정보를 가지고 있음, 계층적인 구조로 정보를 제공
- /run: 부팅 이후 동작 중인 프로세스의 런타임 데이터를 저장하고 있는 디렉터리

<br>

## 2.2.3 부팅(Booting)과 셧다운(Shutdown)

### 부팅의 개요

부팅: 컴퓨터의 전원이 켜진 후 운영체제가 가동되어 사용자가 컴퓨터를 사용할 수 있도록 만들어 주는 과정

- 하드웨어적 단계: 시스템에 장착된 하드웨어 인식, 점검
- 소프트웨어적 단계: 사용자가 운영체제와 응용 프로그램을 사용할 수 있도록 메모리에 상주시킴

부팅 단계

1. 컴퓨터 전원을 켜면 바이오스가 컴퓨터에 장착된 하드웨어 점검
2. 하드웨어 검사가 끝나면 바이오스는 CMOS에 설정된 첫 번째 부팅 하드디스크 확인
3. 첫 번째 하드 디스크의  MBR 영역에 있는 부트 매니저 프로그램 실행
4. 부트 매니저 프로그램이 관련 환경 설정 파일을 참고하여 운영체제 부팅 시작

<br>

### 리눅스 부트 프로세스의 변화

리눅스는 init 프로세스를 사용하여 부팅을 해왔음

init 프로세스 체제는 부팅과 관련된 모든 작업을 init 프로세스에 위임하는 방식

리눅스 시스템은 전원이 켜지고 BIOS 점검이 끝나면 커널이 로드됨 이후 커널은 루트 파일 시스템을 읽기 전용 형태로 마운트 검사 이상이 없는 경우 쓰기 가능 형태로 다시 마운트 그 후 커널은 init 프로세스를 발생시키고, 리눅스 부팅과 관련된 소프트웨어는 init 프로세스에 위임됨

init 프로세스는 리눅스 시스템 내부 최초의 프로세스로 PID = 1 이후 생성되는 프로세스는 모두 fork 방식으로 생성됨

CentOS 7 버전은 init 대신 systemd 사용

→ `pstree` 또는 `ps` 명령어를 사용하면 확인 가능

<br>

### 로그인과 로그아웃

콘솔 기반으로 로그인하는 경우 메시지 파일 내용을 상단에 출력해줌

로그인 메시지 관련 파일

- /etc/issue: 사용자가 로그인할 때 ‘login: ‘이라는 메시지를 보여 주기 전에 출력되는 내용을 적는 파일 (로컬 터미널로 접속할 때 출력되는 메시지 기록)
- /etc/issue.net: /ect/issue 파일과 같은 역할 (텔넷을 통한 네트워크 접속 시 출력되는 메시지 기록)
- /etc/motd: ‘Message Of The Day’의 약어로 성공적으로 로그인되었을 때 보여줄 메시지 기록

리눅스에 로그인만 하고 작업을 하지 않는 경우 작업이 낭비되며 보안 상 위험 야기 가능

`logout` 또는 `exit` 명령어를 통해 로그아웃 가능

일정 시간 동안 작업을 하지 않는 경우 강제적으로 로그아웃 되도록 설정

→ root 권한에서 /etc/profile의 ‘TMOUT=초’ 지정

<br>

### systemd

- systemd의 개요

  System and Service Manager로 시스템의 부팅 및 서비스를 관리해주는 프로그램 (CentOs 7버전부터 사용)

  systemd의 핵심: 유닛이라고 부르는 일종의 대상 파일 (유닛은 다양한 타입을 가짐)

- systemd 관련 디렉터리

  - /etc/systemd/system: 유닛의 환경 설정 파일 위치
  - /run/systemd/system: 런타임 유닛 파일 위치
  - /usr/lib/systemd/system: 시스템에서 사용되는 service 및 target 유닛 파일 위치 (/lib/systemd/system 디렉터리로 접근해도 됨)
  - /etc/systemd/ststemd: 유닛의 환경 설정 파일 위치, 해당 디렉터리 내의 .wants. 디렉터리에는 특정 유닉의 구동에 필요한 유닛들의 설정 파일을 심볼릭 링크로 담고 있음

- systemd의 구조

  - 유닛(unit)

    - service: 서버에서 제공하는 서비스이며 보통 데몬이라고 부름
    - target: 부팅 레벨, 특정 동기화 지점 같이 유닛을 그룹화할 때 사용
    - socket: 프로세스 간 통신에 사용되는 IPC(Inter-process communication) 소켓 의미
    - path: 특정 파일 시스템이 변경될 때까지 서비스의 활성화를 지연시킬 때 사용 (프린팅 시스템의 스풀 디렉터리를 사용하는 서비스에 사용)

  - 서비스(service): 시스템에서 제공하는 서비스(데몬), 다양한 명령으로 제어되는 init 체제와 다르게 `systemctl` 명령어 하나로 제어됨

    매뉴얼 확인 방법: `man systemd.service` 서비스 상태 정보 확인 방법: `systemctl status 서비스명` (.service 생략 가능)

    서비스 상태 주요값

    - loaded: 프로세스 로드되는 유닛의 환경 설정 파일
    - enabled: 부팅 시 활성화됨
    - disabled: 부팅 시 비활성화됨
    - active(running): 프로세스가 하나 또는 그 이상의 프로세스에 의해 동작 중
    - active(exited): 일회성 프로젝트를 성공적으로 실행한 경우
    - active(waiting): 동작 중인 상태 또는 특정 이벤트에 의해 대기 중인 상태
    - inactive(dead): 프로세스가 종료된 상태
    - static: 활성화가 되지는 않지만 활성화되는 다른 유닛에 의해 활성화가 가능한 상태

  - 타깃(target): 부팅과 관련한 타깃의 주요 역할은 특정 레벨에서 특벙 서비스들이 부팅 시 자동으로 활성 또는 비활성 여부를 지정하는 것

    부팅 시 자동 활성화: 실행 파일에 대한 심볼릭 링크 파일 생성 비활성화: 심볼릭 링크 파일 삭제

    - poweroff.target: 시스템 종료
    - rescue.target: 응급복구 모드로 전환
    - emergency.target: rescue.target과 유사, /를 읽기 전용으로 마운트
    - multi-user.target: 콘솔 모드로 전환, 텍스트 기반 로그인만 지원
    - graphical.target: X Window 모드로 전환, X 기반 로그인 지원
    - reboot.target: 재부팅
    - runlevelN.target: N은 0~6까지의 숫자로 부팅과 관련된 런레벨의 심볼릭 링크 (관련 파일: /lib/systemd/system)

  - 소켓(socket): systemd에 의해 제어되면서 소켓 기반으로 동작하는 파일 시스템 FIFO, 네트워크 소켓, IPC 등이 해당

    CentOS 6 이전 버전에서 사용하던 xintd의 메모리 기능을 대체하기도 함

    소켓 유닛 정보 확인: `systemctl list-units --type=socket --all`

- systemd 관련 명령어

  - systemctl: systemd 기반의 시스템 및 서비스 관리 제어 명령어

    ```bash
    systemctl [option] 명령 [서비스명]
    
    ## 주요 옵션##
    # -l, --full: 유닛 관련 정보 출력 시 약어가 아닌 전체 출력
    # -t, --type=: 유닛의 유형 지정, 사용 가능한 유형의 경우 '-t help'로 확인
    # -a, --all: 유닛 정보 출력 시 모든 유닛 지정
    
    ## 런레벨 관련 주요 명령 ##
    # get-default: 현재 시스템에 설정된 런레벨 target 정보 출력
    # set-default 타깃명: 시스템의 런레벨을 지정한 target으로 변경
    # isolate 타깃명: 지정한 타깃의 런레벨로 즉시 변경
    # rescue: 응급 복구 모드로 즉시 전환
    # poweroff: 시스템을 즉시 종료
    # reboot: 시스템을 즉시 재부팅
    
    ## 상태 정보 관련 주요 명령 ##
    # list-units: 유닛 관련 정보 출력, 아무 옵션 없이 systemctl 명령 사용 시 기본 적용 (이름이 긴 경우 약어로 표기)
    # list-unit-files: 설치된 유닛 파일의 목록 및 상태 정보 출력
    # list-sockets: 소켓 관련 유닛 정보 출력
    # list-dependencies: 명시된 유닛의 의존성 관련 있는 유닛 정보 출력, 특별히 명시된 유닛이 없는 경우 기본 타식의 의존성 정보 출력
    
    ## 서비스 제어 관련 주요 명령 ##
    # enable 서비스명: 부팅 시 특정 서비스를 구동시킴
    # disable 서비스명: 부팅 시 특정 서비스를 구동시키지 않음
    # is-enabled 서비스명: 부팅 시 특정 서비스가 구동되는지 여부 확인
    # start 서비스명: 특정 서비스 즉시 시작
    # stop 서비스명: 특정 서비스 종료
    # restart 서비스명: 특정 서비스 재시작
    # reload 서비스명: 특정 서비스의 환경 설정만 다시 읽어들임
    # mask 서비스명: 특정 서비스의 유닛 파일을 /dev/null로 링크시켜 시작되는 것을 막음
    # unmask 서비스명: mask 설정된 서비스 해제
    # is-active 데몬명: 특정 데몬이 활성화되어 있는지 여부 검사
    # status 데몬명: 특정 데몬에 대한 상태 정보 출력
    # kill 데몬명: 특정 데몬의 프로세스 종료
    # daemon-reload: systemd 매니저 관련 환경 설정 다시 읽어들
    ```

  - systemd-analyze: 시스템 부팅과 관련된 성능을 분석해주는 명령

    ```bash
    systemd-analyze [argument]
    
    ## 주요 인자값 ##
    # time: 부팅 시 소요된 시간 정보 출력 (default)
    # blame: 서비스별로 부팅에 소요된 시간 출력
    # critical-chain: 각 유닛의 시간을 트리 형태로 출력 (@ 문자 다음에 표시되는 시간: 유닛이 시작/활성화되기까지 소요된 시간, + 문자 다음에 표시되는 시간: 유닛을 시작하는데 소요된 시간)
    # plot: 관련 정보를 SVG 이미지 파일로 생성
    ```

- systmed 로그 관리

  systemd 관련 로그는 systmed-journald가 생성하고 관리 관련 정보는 메타 데이터로 /run/log/journal 디렉터리에 저장되며 재부팅하면 사라짐

  로그 관리 명령어: journalctl

  ```bash
  journalctl [option] [항목]
  
  ## 주요 옵션 ##
  # -l, --full: 출력 가능한 모든 필드의 정보 출력
  # -r, --reverse: 역순으로 가장 최근 정보부터 출력
  # -p, --priority=: syslog에 사용하는 로그 레벨 지정, 로그 레벨명이나 숫자값을 적으며 지정한 레벨 이상의 정보 출력
  #   높은 순: emerg(0), alert(1), crit(2), err(3), warning(4), notice(5), info(6), debug(7)
  # --since=: 특정 날짜 이후의 정보 출력 (형식: yyyy-MM-dd hh:mm:ss)
  # --until=: 특정 날짜까지의 정보만 출력 (형식: yyyy-MM-dd hh:mm:ss)
  ```

  /run/log/journal 디렉터리에 저장되는 정보는 휘발성 정보이기 때문에 지속적 로그 관리를 위해서는 /var/log/journal 디텍터리를 실행하고 관련 명령을 실행해야 함

  ```bash
  mkdir -p -m2775 /var/log/journal 
  # -p, --parents: 상위 경로도 함께 생성
  # -m, --mode=: 권한 설정 (default: 755)
  chgrp systemd-journal /var/log/journal
  # chgrp: 파일이나 디렉터리 그룹 변경
  killall -USR1 systemd-journald
  # killall: 특정 프로세스 한번에 죽이기
  # USR1: 사용자 지정 시그널로 애플리케이션마다 상이
  ```

  로그 파일 환경 설정: /etc/systemd/journald.conf에서 제어

- 시스템 설정 주요 명령어

  - timedatectl: 시스템의 날짜 및 시간을 확인/설정

    ```bash
    timedatectl [command]
    
    ## 주요 command ##
    # status: 시스템의 시간 및 RTC의 시간 정보 출력
    # set-time: 시스템의 시잔 설정 (형식: yyyy-MM-dd hh:mm:ss)
    # set-timezone: 타임존 설정
    # set-ntp: NTP 사용 여부 지정 (1: 사용, 0: 미사용)
    ```

  - hostnamectl: 시스템에 설정된 호스트명 정보 출력/설정

    ```bash
    hostnamectl [command] [설정값]
    
    ## 주요 command ##
    # status: 시스템에 설정된 호스트명과 관련된 정보 출력 (default)
    # set-hostname: 호스트명 설정 시 사용
    ```

<br>

### 시스템 종료(shutdown)

- shutdown: 시스템을 재시작하거나 전원을 종료하는 명령어로 root 권한자만 가능

  해당 옵션에 따라 적당한 실행 레벨을 인식하고 init 프로세스를 호출하여 요청하므로 다른 방법에 비해 안전하고 조직적임

  ```bash
  shutdown [option] 시간 [경고메시지]
  # 시간의 경우 +m 형식(m분 후 셧다운)과 hh:mm 형식(시간 직접 지정) 모두 사용 가능
  
  ## 주요 옵션 ##
  # -r: 시스템 재부팅
  # -h: 시스템 종료 (=halt)
  # -c: 예약된 셧다운 명령 취소
  # -k: 실제로 셧다운하지 않고 경고 메시자만 접속한 사용자들에게 전송
  ```

- reboot: 시스템 재시작 명령어로 리눅스 배포판에서 로컬로 접속한 사용자 모두 사용 가능

  ```bash
  reboot [option]
  
  ## 주요 옵션 ##
  # -w: 시스템을 재부팅하지 않고 /var/log/wtmp에 셧다운한 기록만 저장
  # -f: init을 호출하지 않고 즉시 재부팅
  ```

- halt: 시스템 종료 명령어로 리눅스 배포판에서 로컬로 접속한 사용자 모두 사용 가능

  ```bash
  halt [option]
  
  ## 주요 옵션 ##
  # -p: 시스템 종료 후 전원까지 끄는 경우 사용 
  ```

- poweroff: 시스템 종료 및 전원 끄기

- init, telinit: init 프로세스에 직접 요청하여 실행 레벨을 변경하는 경우 사용, 빠르게 실행되나 실행 중인 프로세스를 무조건적으로 종료하기 때문에 권장하지 않음

  ```bash
  init 실행레벨
  ```

<br>

## 2.2.4 파일 시스템의 이해

### 파일 시스템의 개요

파일 시스템: 운영체제가 파티션이나 디스크에 데이터를 저장, 읽기, 쓰기, 찾기 위해 구성하는 일련의 체계

운영체제 설치 시 구성되며 파일 시스템의 성능은 운영체제의 성능에도 밀접한 관계가 있음

파일 시스템의 기능

- 사용자가 파일을 생성, 수정, 삭제할 수 있도록 제공
- 사용자가 파일을 사용하기 적합한 형태의 구조로 구성하고 다양한 추가 정보 제공
- 다른 사용자와 파일을 공동으로 사용할 수 있는 적절한 제어 방법 제공
- 파일 공유를 위해 다양한 접근 제어 방법 제공
- 백업, 복구를 위한 기능
- 사용자와 장치 간의 독립성 유지를 위해 물리적인 장치 이름 대신 적절한 이름 제공
- 정보의 암호화 및 복호화 기능 제공
- 사용자가 파일이나 디렉터리에 접근하기 쉬운 인터페이스 및 명령어 제공

<br>

### 리눅스 파일 시스템의 개요

- minix: 초기 리눅스 파일 시스템의 모태, 파티션 사이즈가 64MB로 제한되며 파일 이름도 14자까지만 지원, 단일 타임스탬프 체제, 램 디스크나 부팅 디스크에 주로 이용
- ext: UFS 구조 기반, 파티션 사이즈는 2GB이며 파일명은 255자까지 가능, 파일 접근에 대한 타임스탬프, 아이도느 수정 등을 지원하지 않음
- ext2: 아이노드의 불변성과 타임스탬프 수정 문제 해결, 2GB까지의 단일 파일 생성 지원
- ext3: 4K 블록 사용 시 최대 2TB의 단일 파일 생성, 16TB의 파일 시스템 구성, 저널링 파일 시스템이며 ACL을 통한 접근제어 지원
- ext4: ext2, ext3와 호환성이 있는 확장 버전, 64비트 기억 공간을 없애고 최대 1EB의 디스크 볼륨과 16TB의 파일 지원
- Reiserfs: 저널링 파일 시스템으로 리눅스 커널 2.4.1에 포함
- XFS: SGI에서 개발한 저널링 파일 시스템으로 리눅스 커널 2.4.25에 포함, 최대 16EB의 디스크 볼륨과 8EB의 파일 지원, RHEL 7의 기본 파일 시스템
- JFS: 저널링 파일 시스템으로 리눅스 커널 2.4.24에 포함
- xiafs: 안정성 강화, 리눅스 커널 2.1.21부터 제외
- msdos: FAT 파일 시스템과 호환, 8.3 구조 형태
- umsdos: 리눅스에서 MS-DOS 파일 시스템을 확장하여 만든 것으로 긴 파일명, UID/GID 등 지원
- vfat: FAT-32와 호환
- isofs: CD-ROM을 위한 파일 시스템
- nfs: 네트워크 상의 시스템 파일들을 공유할 때 사용
- smbfs: SMB 프로토콜을 구현한 파일 시스템
- cifs: smbfs의 확장
- ncpfs: NCP 프로토콜을 구현
- sysv: SystemV/Coherent 파일 시스템을 리눅스에 구현
- proc: 리눅스에서 사용하는 가상 파일 시스템

<br>

### 저널링 파일 시스템

파일 시스템에 대한 변경 사항을 반영하기 전 저널이라 부르는 로그에 변경 사항을 저장하여 추적이 가능하게 만든 파일 시스템

시스템에 충돌 현상이 발생하거나 전원 문제가 발생한 경우 데이터 복구 확률을 높여 줌

파일 시스템 검사 명령인 fsck(file system check)에 걸리는 시간을 단축하기 위해 데이터를 디스크에 쓰기 전 로그에 남겨 비정상적인 종료에도 로그를 사용해 fsck 보다 빠르고 안정적인 복구 기능을 제공하는 기술

<br>

### ext 파일 시스템의 구조

ext2 파일 시스템은 부트 블록(부트 섹터)과 블록 그룹으로 구성

- 블록: 파일 시스템에서 기본적으로 데이터를 저장하는 단위

- 블록 그룹: 슈퍼 블록, 그룹 기술자, 블록 비트맵, 아이노드 비트맵, 아이노드 테이블(아이노드 블록), 데이터 블록으로 구성, 슈퍼 블록과 그룹 기술자는 마운트될 때 Group-0의 정보를 가져오지만 손상될 때를 대비해 모든 Group에 사본이 저장되어 있음

- 슈퍼 블록: 파일 시스템에 대한 전체적인 정보를 가짐, 주요 정보로는 매직 넘버, 마운트 정보 등이 있음

- 매직 넘버: 특정 파일 시스템임을 알리는 정보로서 ext의 경우 0xEF53

- 그룹 기술자: 각각의 블록 그룹을 기술하는 자료 구조로 다음 주요 정보들이 저장됨

- 블록 비트맵: 블록의 사용 현황을 비트로 표현, 각 디스크 블록 당 하나의 비트 할당

- 아이노드 비트맵: 아이노드 할당 상태를 비트로 표현

- 아이노드 테이블: 아이노드에 대한 정보가 들어있는 영역

- 데이터 블록: 파일이 보관해야 하는 정보를 저장하는 영역

- 간접 블록: 추가적인 데이터 블록을 위한 포인터들이 사용할 동적으로 할당되는 공간

- 홀: 아이노드나 간접 블록 안의 데이터 블록의 주소로 특별한 값 저장, 실질적으로 디스크 상에 공간이 할당되지는 않음

- 아이노드: 전통적 유닉스 계열 파일 시스템에서 사용하는 자료 구조로 각각의 파일은 하나의 아이노드를 할당받아 관리함, 일반적으로 파일 시스템을 생성할 때 전체 공간의 1%를 아이노드를 위해 할당, 파일 시스템에서 생성할 수 있는 파일의 최대 개수도 한정되어 있음

<br>

### XFS

SGI에서 고성능의 64비트 저널링 파일 시스템을 구현하기 위해 개발됨

<br>

특징

- 빠른 복구를 위해 메타데이터 저널링을 지원
- 마운트되어 활성화된 상태로 조각 모음 및 확장 지원
- 데이터 읽기/쓰기 트랜잭션으로 인한 성능 저하 최소화
- raw I/O 성능에 가까운 성능을 낼 수 있는 처리량을 보임
- 완전한 64비트 파일 시스템이기 때문에 높은 확장성 제공

<br>

XFS 최대 지원 내역

- 최대 볼륨 사이즈: 8 exbibytes
- 최대 파일 사이즈: 8exbibytes
- 최대 파일 개수: 2^64
- 최대 파일 이름 크기: 255bytes

<br>

XFS는 블록을 기반으로 하는 파일 시스템의 한계 극복을 위해 extent 기반 할당을 사용하여 지연 할당, 명시적인 사전 할당 같은 여러 할당 체계를 가짐

익스텐트 기반 할당: 파일 시스템에서 사용된 공간을 추적하는 것보다 간결하고 효율적인 방법 제공, 대용량 파일의 성능 향상

지연 할당: 파일이 연속적인 블록 그룹에 기록될 가능성을 높이는 것으로 단편화를 줄이고 성능을 향상시킴

사전 할당: 애플리케이션이 사전에 기록해야 할 데이터 양을 알고 있는 경우 완전히 조각화하는 것을 방지하는데 사용될 수 있음

<br>

XFS의 자료 구조

- B-Tree: 이진 트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조

  일반적인 이진 트리보다 많은 자식 노드를 가질 수 있으므로 트리 높이가 낮아져서 방문해야 할 노드의 수자 줄어듦

  자료를 정렬된 상태로 보관하며 각 노드는 검색에 사용할 키를 가지고 있고 각각의 키는 그에 연관된 데이터를 가리키는 포인터 정보 유지

- B+ 트리: 모든 레코드들이 트리의 가장 하위 레벨인 리프 노드에 정렬되어 있고 이를 순차적으로 연결한 구조

  중간 노드에는 리프 노드에 있는 키 값을 찾아갈 수 있는 키들만이 내부 블록에 저장됨

  리프 노드들은 Linked List로 연결되어 있어 파일의 내용을 순서대로 읽는 경우와 순차적 접근 처리에 효율적

<br>

XFS 데몬

- xfssyncd: 로그 정보와 메타 데이터 정보들을 기록하는 역할 수행
- xfsbufd: I/O 요청 처리
- xfsdatad, xfslogd: 작업 큐에 수행할 작업이 있는 경우 관련 함수를 호출해서 수행하는 역할

<br>

XFS의 디스크 구조

- 할당 그룹: XFS는 할당 그룹이라는 단위로 나눠지고 각각의 할당 그룹은 독립적으로 존재하며 병렬적으로 처리됨

  파일 시스템 생성 시 크기, 수 지정 가능, 지정하지 않은 경우 8개의 할당 그룹 생성

  각 할당 그룹의 0번 블록에는 슈퍼 블록 정보가 저장되고 나머지 블록에는 할당 그룹 헤더 정보가 저장됨

  마운트 시 첫 번째 할당 그룹의 슈퍼 블록만을 사용하며 나머지는 슈퍼 블록의 데이터가 깨졌을 때 응급 복구에 사용

- 아이노드: 아이노드의 구조는 디스크 상에 직접 기록되는데, 필요에 따라 크기가 증가할 수 있는 가변적 구조로 설계됨

<br>

# 2.3 X 윈도

## 2.3.1 X 윈도의 개념 및 특징

### X 윈도의 역사

플랫폼과 독립덕으로 작동하는 그래픽 시스템 개발을 위한 프로젝트의 일환

<br>

### XFree86

IBM 호환 시스템을 사용하는 유닉스 계열 운영체제를 위한 X 윈도 프로젝트

현재는 X.org로 변경됨

<br>

### X.org

X.org Foundation에서 관리되는 X 서버 패키지로 소스가 공개된 자유 소프트웨어

현재 리눅스를 비롯하여 유닉스 대부분이 해당 프로젝트 기반의 X 윈도 시스템 사용

<br>

### X 윈도 특징

네트워크 프로토콜에 기반한 그래픽 사용자 인터페이스 환경

디스플레이 장치에 의존적이지 않음

이식성이 뛰어나고 그래픽 환경에 필요한 자원들이 특정한 형태로 정의되어 있지 않아 사용자가 원하는 모양의 인터페이스 생성 가능

<br>

### X 윈도의 구조

클라이언트/서버 구조로 되어 있고 통신을 위해 X Protocol을 사용

X 서버: 그래픽하게 보여 주는 하나의 시스템

X 클라이언트: X 서버 위에 동작하는 일종의 응용 프로그램

네트워크 기반이기 때문에 로컬 사용자가 키보드나 마우스로 입력하면 TCP 포트 6000번을 통해 전달되고 관련 X 클라이언트 프로그램이 실행됨

/tmp/.X11-unix/X0라는 Unix Domain Socket을 이용하여 X 서버와 X 클라이언트가 통신

로컬 시스템 뿐 아니라 원격의 호스트 간에도 응용프로그램을 주고받을 수 있음

<br>

### Xlib와 X 관련 라이브러리

Xlib: C 언어로 구현된 클라이언트 라이브러리로 X 서버와 대화하는 역할, 저수준의 인터페이스로 단순한 기능만 가짐

XCB: X.org에서 Xlib를 대체해 사용됨, 햫상된 스레딩 기능을 지원하고 확장성이 뛰어남, 라이브러리의 크기가 작고 단순하며 X 프로토콜에 직접 접근 가능

<br>

## 2.3.2 X 윈도 설치와 진행

### X 윈도 설치

```bash
# 관련 패키지 그룹 검색
yum group list

# 설치 가능한 데스크톱 목록 확인 후 설치
yum group install 'GNOME Desktop'
ymm group install 'KDE Plasma Workspaces'
yum group install 'Server with GUI'
```

<br>

### X 윈도의 실행

```bash
# 부팅 모드의 확인
systemctl get-default
# multi-user.target: 텍스트 모드 (runlevel3.target)
# graphical.target: X 윈도 실행 모드 (runlevel5.target)

# 부팅 모드의 변경
systemctl set-default TARGET_NAME
```

<br>

### 디스플레이 매니저

XDM, GDM, KDM이 있으며 CentOS 7에서는  GDM을 기본 디스플레이 매니저로 사용

KDE 데스크톱을 사용하려면 다음 방법 진행

```bash
# KDE Plasma Workspace 설치
yum group install 'KDE Plasma Workspaces'

# 콘솔 모드로 로그인한 사용자의 X 관련 설정 파일에 KDE로 지정
echo "exec startkde" >> ~/.xinitrc

# X 윈도 호출 명령 실행
startx
```

<br>

### startx

X 윈도를 실행시키는 스크립트로 시스템 환경을 초기화시키고, 시작하는 데 필요한 여러 프로그램을 호출하고, 최종적으로 xinit을 호출하는 명령

```bash
startx [option]

## 주요 옵션 ##
# --: 명령행의 인자값을 xinit에 넘김
```

<br>

### X 윈도의 설정 변경

xrandr: 명령행에서 화면 크기, 방향 등을 확인/변경하는 명령

```bash
xrandr [options]

## 주요 옵션 ##
# -s: 화면 크기(해상도) 변경 시 사용
```

<br>

## 2.3.3 데스크톱 환경

### 데스크톱 환경(Desktop Environment; DE)

GUI 환경을 이용하기 위해 사용자에게 제공되는 인터페이스 스타일

리눅스에서 사용하는 대표적인 데스크톱 환경에는 GNOME, KDE, Xfce, LXDE 등이 있음

<br>

### KDE(K Desktop Environment)

관련 패키지 설치: `yum install konq-plugins`

포함되어 있는 주요 프로그램

- konqueror: 웹 브라우저 및 파일 관리
- dolphin: 파일 관리
- kwrite: 텍스트 편집기
- Gwenview: 이미지 뷰어
- KColorChooser: 색상 선택
- KColorEdit: 색상 팔레트 편집
- KIconEdit: 아이콘 편집
- KRuler: 스크린 자
- KSnapshot: 스크린 캡처
- KolourPaint: 페인트
- Okular: 문서 뷰어
- KGet: 다운로드 관리자
- KMail: 메일 클라이언트
- Konsole: 터미널
- KDiskFree: 디스크 사용량 뷰어
- KSytemLog: 시스템 로그 뷰어
- KUser: 사용자 관리
- Krfb: 데스크톱 공유
- Dragon Player: 비디오 재생
- Juk: 음악 재생

<br>

### GNOME(GNU Network Object Model Environment)

GPL 라이선스를 따르지 않는 Qt 라이브러리 기반의 KDE의 대안으로 시작

<br>

포함된 주요 프로그램

- nautillus: 파일 관리
- Cheese: 웹캠을 이용한 사진 및 비디오 추출
- GIMP: 이미지 편집, 변환, 생성
- Rhythmbox: 인터넷 라디오 및 음악 연주
- gThumb: 이미지 뷰어 및 편집
- gnome-terminal: 터미널
- gedit: 문서 편집
- evince: 문서 뷰어
- totem: 사운드 및 비디오 플레이어
- gnome-system-monitor: 프로세스 및 자원 모니터링
- sound-juicer: CD 플레이어
- evolution: 메일, 달력, 주소록 관련

<br>

## 2.3.4 윈도 매니저(Window Manager)

### 윈도 매니저란?

X 윈도 환경에서 윈도의 배치와 표현을 담당하는 시스템 소프트웨어

직접 마우스, 키보드 등에 접근하지 않고 디스플레이 서버를 통해 접근

<br>

### 윈도 매니저의 종류

GNOME에 사용되는 Mutter, Metacity

KDE에 사용되는 KWin, KWM

<br>

## 2.3.5 웨이랜드(Wayland)

### 개요

클라이언트가 해당 프로토콜의 C라이브러리 구현뿐만 아니라 클라이언트와 대화할 수 있는 compositor를 위한 프로토콜

X를 대체할 목적으로 등장, X보다 개발 및 유지보수를 쉽게 하려는 것이 주목적

Weston: Wayland 프로젝트의 일부로 compositor를 구현함, 클라이언트 또는 Linux KMS로 실행 가능하며 데모 클라이언트가 함께 제공됨, 용량이 작고 빠름

<br>

### X와 Wayland의 그래픽 처리 과정 비교

X의 그래픽 처리 과정

1. 리눅스 커널에서 입력 장치로부터 관련 이벤트를 수신하고 X 서버에 이벤트 전달
2. X 서버가 X 클라이언트에게 이벤트 전달 (실제 처리는 compositor에서 수행)
3. X 클라이언트는 수신한 이벤트를 분석하여 X 서버에 맞는 렌더링 요청
4. X 서버는 렌더링 영역을 연상하고 compositor에게 화면 갱신 요청
5. compositor는 화면 갱신 영역에 맞게 화면 합성 후 X 서버에 요청
6. X 서버는 compositor의 back buffer의 내용을 front buffer 로 카피하거나 pageflip을 수행하고 커널을 통해 최종 화면 출력

<br>

Wayland의 그래픽 처리 과정

1. 리눅스 커널에서 입력 장치로부터 커널 이벤트 수신 후 Wayland Compositor에게 이벤트 전달
2. Compositor.가 이벤트를 처리할 Wayland 클라이언트에게 이벤트 전달
3. Wayland 클라이언트가 자신의 윈도우에 대해 직접 렌더링을 수행하고 업데이트된 영역을 나타내기 위해 관련 요소가 필요한 경우에만 compositor에게 요청
4. compositor는 각 클라이언트의 damage event 요청을 수집하여 화면 재구성, KMS와 함께 pageflip 스케줄을 위해 ioctl을 직접 발생

<br>

## 2.3.4 X 윈도 활용

### 원격지에서 X 클라이언트 이용

- xhost: X 서버에 접근할 수 있는 클라이언트를 지정/해제하는 명령

  ```bash
  xhost [+|-] [IP 주소 or 도메인명]
  ```

- DISPLAY: X  클라이언트 프로그램이 실행될 때 표시되는 창이 설정되어 있는 환경 변수, X 클라이언트를 원격지로 전송하기 위해서는 해당 값을 원격지의 주소로 변경하면 됨

  ```bash
  export DISPLAY="IP 주소"
  ```

  Error: cannot open display 발생 시 X Server에서 다음 설정 확인

  ```bash
  # xhost로 X Client 허가 확인 후 허가되어 있지 않은 경우 다음 형식으로 허가
  xhost + [IP 주소]
  
  # 방화벽 해제
  systemctl stop firewalld
  iptables -F
  
  # sshd 관련 설정 확인
  vi /etc/ssh/sshd_config
  AddressFamily inet
  
  X11 orwarding yes
  X11DisplayOffset 10
  X11 JseLocalhost no
  
  # /etc/gdm/custom.conf 파일에서 다음과 같이 두 줄 추가
  [security]
  DisallowTCP=false
  
  [xdmcp]
  Enable=true
  
  # 시스템 재시작
  reboot
  ```

- xauth: X 접근 허가 파일 관련 도구

  MIT-MAGIC-COOKIE-1이라는 키 값을 가지고 X 서버로 접근하면 해당 사용자로 인증하여 사용 가능

<br>

## 2.3.7 X 윈도 주요 응용 프로그램

### GIMP

GNU Image Manipulation Program을 사진이나 그림을 편집하는 자유 소프트웨어

```
yum install gimp
```

<br>

### Totem

GNOMW 데스크톱 기반의 영화 플레이어

명령행에 totem이라고 입력하면 실행됨

<br>

### ImafeMagick

비트맵 이미지를 보여주고 생성 및 편집이 가능하도록 지원해주는 프로그램 패키지

```
yum install ImageMagick
```

<br>

### eog

Eye of GNOME으로 이미지 뷰어 프로그램

명령행에서 eog라고 입력하면 실행 가능

<br>

### shotwell

GNOME 기반의 이미지 뷰어 및 편집기

<br>

### kdegraphics

KDE에서 제공하는 그래픽 관련 프로그램 패키지

<br>

### Rhythmbox

통합형 음악 관리 프로그램

<br>

### LibreOffice

오피스 프로그램 패키지

<br>

# 2.4 셸(Shell)

## 2.4.1 셸의 이해

### 셸의 개념 및 특징

셀은 커널과 사용자 간의 다리 역할을 하는 것으로 사용자로부터 명령을 받아 해석하고 프로그램을 실행하는 역할을 함

사용자가 로그인하면 각 사용자에게 설정된 셸이 부여됨, 셸이 부여되지 않는 경우 명령을 수행할 수 없으므로 로그인을 막는 효과

<br>

주요 셸의 특징

- Bourne Shell: 유닉스 버전 7의 기본 셸

- bash: 본 셸을 기반으로 하여 만들어졌으며 현재 리눅스의 표준 셸, bash의 명령어 문법은 sh와 호환되고 POSIX와도 호환됨

  명령 히스토리, 명령어 완성 기능, 히스토리 치환, 명령행 편집 등 지원

- C 셸: C언어 기반, 강력한 프로그램 작성 기능

  히스토리 기능, 별명 기능, 작업 제어 등 유용한 기능을 포함하였으며 명령행 편집 기능은 지원하지 않음

- tcsh: csh의 기본 기능에 명령어 완성 기능, 명령행 편집 기능 추가로 지원

- ksh: 본 셸을 확장해 만들어졌으며 C 셸의 많은 기능 추가

- dash: /bin/sh를 가능한 작게 구현한 셸로 빠른 작업 수행이 특징, history 명령 등은 지원하지 않음

<br>

### 셸의 확인과 변경

- 셸의 확인: `echo $SHELL`

- 변경 가능한 셸 확인: `chsh -l` 또는 `cat /etc/shells`

- 셸의 변경: `chsh` (다음 로그인부터 유효)

  명령행에서 `/bin/csh`와 같이 실행하여 셸을 변경할 수 있는데 기본 bash 셸에서 포크되어 추가로 프로세스 발생, 해당 경우 변경된 셸 확인은 ps 명령어로 가능하며 exit 입력 시 기본 셸로 돌아감

- 사용자의 로그인 셸 정보 확인: `grep [사용자명] /etc/passwd`

  사용자의 로그인 셸 정보는 /etc/passwd의 7번째 필드에 기록됨

- chsh: 사용자의 로그인을 변경하는 명령어(로그인 셸을 변경하는 것이므로 실제 적용은 다음 로그인부터)

  ```bash
  chsh [option] [사용자명]
  
  ## 주요 옵션 ##
  # -s: 변경하고자 하는 셸 명시
  # -l: 사용 가능한 셸의 목록 정보 출려 (/etc/shells 파일 내용 출력)
  # -u: chsh 명령어의 사용법 출력
  # -v: 설치한 패키지 버전 출력
  ```

<br>

### 셸 변수와 환경 변수

- 셸 변수: 특정한 셸에서만 적용되는 변수

  리눅스에서는 명령행에서 ‘변수명=값’ 형태로 지정해 사용 가능

  변수값 출력 시 변수명 앞에 $를 붙이고 echo 명령어로 확인 가능

  선언된 셸 변수를 전부 확인하려면 set 명령 사용

- 환경 변수: 셸의 환경을 정의하는 중요한 역할을 수행하는 변수

  미리 예약된 변수명을 사용하며 bash에서는 대문자로 된 변수로 구성되어 있음

  현재 설정된 전체 환경 변수의 값은 env 명령으로 확인 가능

  환경 변수의 값 확인과 설정은 일반 셸 변수 설정 방법과 같음

  <br>

  주요 환경 변수

  - HOME: 사용자의 홈 디렉터리
  - PATH: 실행 파일을 찾는 디렉터리 경로
  - LANG: 셸 사용 시 기본으로 지원되는 언어
  - TERM: 로그인한 터미널 조율
  - PWD: 사용자의 현재 작업 디렉터리
  - SHELL: 사용자의 로그인 셸
  - USER: 사용자의 이름
  - DISPLAY: X 윈도에서 프로그램 실행 시 출력되는 창
  - PS1: 프롬프트 변수
  - PS2: 2차 프롬프트 변수
  - HISTFILE: 히스토리 파일의 절대 경로
  - HISTSIZE: 히스토리 파일에 저장되는 명령어의 개수(줄 기준)
  - HISTFILESIZE: 히스토리 파일의 파일 크기
  - HISTCONTROL: 중복되는 명령에 대한 기록 유뮤 지정
  - HISTTIMEFORMAT: history 명령 실행 시 출력되는 시간 형식 지정
  - HOSTNAME: 시스템의 호스트명
  - MAIL: 도착한 메일이 저장되는 경로
  - TMOUT: 사용자가 로그인한 후 일정 시간 동안 작업을 하지 않을 경우 로그아웃시키는 시간(초)
  - UID: 사용자의 UID

  <br>

  주요 프롬프트 형식

  - \d: ‘요일 월 일’ 형태로 날짜 표시
  - \h: 호스트 이름 표시
  - \s: 사용 중인 셸 이름 표시
  - \t: 24시 형태의 현재 시간 표시
  - \T: 12시 형태의 현재 시간 표시
  - \@: 12시 형태의 현재 시간에 AM/PM 추가호 표시
  - \u: 현재 사용자의 이름 표시
  - \w: 현재 작업 디렉터리를 절대 경로로 표시
  - \W: 현재 작업 디렉터리 중 마지막 디렉터리만 표시
  - \!: 현재 명령의 히스토리 넘버 표출
  - \\: \를 표시

<br>

### bash의 주요 기능

- 명령행 완성 기능: 명령 입력 시 글자 일부분만 입력하고 TAB 키를 누르면 나머지 부분을 자동 완성 시켜주는 기능

  여러 개가 존재하는 경우 TAB 키를 한 번 더 눌러 목록 확인 가능

- 명령어 History 기능: 입력 후 실행했던 모든 명령은 히스토리 리스트 버퍼에 스택으로 저장됨, 해당 명령들은 위/아래 방향키를 사용하여 검색 및 편집 가능

  사용자들이 실행한 명령은 각 사용자의 홈 디렉터리 내부 .bash_history 파일에 기록됨

  - history: 사용자가 입력한 명령어를 확인하는 명령으로 ‘!’로 대체 가능

    ```bash
    history [숫자값]
    
    ## !와 히스토리 명령문 ##
    # !!: 마지막에 사용한 명령 실행
    # !n: n번째 사용한 명령 실행
    # !-n: 사용한 명령 목록을 역으로 세어서 n번째 명령 실행
    # !문자열: 가장 최근에 사용한 명령 중 '문자열'로 시작하는 명령을 찾아서 실행
    # !?문자열?: 가장 최근에 사용한 명령 중 '문자열'을 포함하는 명령을 찾아서 실행
    # ^문자열1^문자열2: 마지막으로 사용한 명령문의 '문자열1'을 '문자열2'로 대체한 후 실행
    ```

    history 관련 키 조합

    - ctrl + r: 검색할 수 있는 명령 프롬프트가 나타나고 특정한 문자를 입력하면 가장 최근에 그 문자로 수행한 명령을 보여 줌, enter로 실행 가능
    - ESC 후 . : 최근에 사용된 인자를 명령행에 붙여줌
    - ALT + . : 최근에 사용한 인자를 하나씩 호출

- alias 기능

  - alias 지정: `alias 나만의명령어=’기존 명령어 조합’`
  - alias 해제: `unalias 지정한명령어`

  특정 명령어에 옵션이 기본적으로 실행되도록 alias를 설정한 경우 원래 명령을 일시적으로 실핸하는 방법

  - which 명령어를 통해 실행할 명령어의 위치를 파악한 후 절대 경로로 실행
  - 명령어 앞에 \를 붙임

  셸 상태에서 설정한 alias는 재로그인하거나 재부팅하면 다시 설정해야 함 지속적으로 사용하려면 .bashrc에 설정

- 명령행 편집 기능

  - ctrl+b: 커서를 왼쪽으로 한 칸 이동
  - ctrl+f: 커서를 오른쪽으로 한 칸 이동
  - ESC 후 b: 커서를 왼쪽으로 한 단어 이동
  - ESC 후 f: 커서를 오른쪽으로 한 단어 이동
  - ctrl+a: 맨 왼쪽으로 이동
  - ctrl+e: 맨 오른쪽으로 이동
  - ctrl+d: 커서 오른쪽 한 글자 삭제
  - ESC 후 backspace: 커서 왼쪽 한 단어 삭제
  - ESC 후 d: 커서 오른쪽 한 단어 삭제
  - ctrl+k: 커서 왼쪽 행 전체 삭제
  - ctrl+u: 행 전체 삭제
  - ctrl+y: 삭제 취소

- 명령 대체 기능: 특정 명령의 결과를 다른 명령의 인자값으로 사용하는 것

  ``(Backquotes)나 $()를 이용해 대체 가능

- 그룹 명령 실행

  - ; : 단순히 한 줄에 여러 명령을 나열하기 위해 사용, 입력한 순서대로 순차 처리
  - || : 논리적 OR, 앞의 명령이 성공이면 결과를 출력하고 그렇지 않으면 뒤의 명령을 실행하여 결과 출력
  - && : 논리적 AND, 앞의 명령이 성공해야만 다름 명령 수행

- 표준 입출력 제어 기능

  - 표준 입력: stdin, 셸에서는 0으로 표기
  - 표준 출력: stdout, 셸에서는 1로 표기하며 생략 가능
  - 표준 에러: stderr, 셸에서는 2로 표기

- 리다이렉션: 어떤 프로세스의 입/출력을 표준 입출력이 아닌 다른 입출력으로 변경할 때 사용

- 파이프: 프로세스의 통신을 위해 도입한 것으로 어떤 프로세스의 표준 출력이 다른 프로세스의 표준 입력으로 쓰이게 하는 것

  ```bash
  명령어1 | 명령어2
  # 명령어1의 결과값이 명령어2의 입력으로 사용됨
  
  # tee: 파이프 연결 출력을 두 갈래로 나눌 때 사용
  tee [option] [파일]
  
  ## 주요 옵션 ##
  # -i: 인터럽트 무시
  # -a: 지정된 파일로 출력을 덮어쓰지 않고 파일 내용 뒤에 추가
  
  # xargs: 표준 입력으로부터 값을 받아 처리하는 명령
  명령어 | xargs [option]
  
  ## 주요 옵션 ##
  # -n 값: 한 번에 처리하는 최대 인자값을 지정하는 옵션
  ```

- 작업 제어 기능

- 산술 연산 기능

  ```bash
  expr 값 연산자 값
  # * 연산 사용 시 \\* 처럼 사용해야 함
  
  echo $[값 연산자 값]
  # $[]를 사용하는 경우 띄어쓰기를 하지 않아도 되며, * 사용 시에도 \\를 붙이지 않아도 됨
  ```

- 프롬프트 제어 기능

- 확장된 내부 명령어

<br>

### bash 관련 파일 및 디렉터리

- /etc/profile: 시스템 전체에 적용되는 환경 변수와 시작 관련 프로그램 설정
- /etc/bashrc: 시스템 전체에 적용되는 alias와 함수 설정
- ~/.bash_profile: 개인 사용자의 환경 설정, 시작 프로그램 설정과 관련 있는 파일로 로그인 시 읽어들임
- ~/.bashrc: 개인 사용자가 정의한 alias와 함수들 존재
- ~/.bash_logout: 개인 사용자가 로그아웃할 때 수행하는 설정 지정
- /etc/profile.d: 응용 프로그램들이 시작하기 위해 필요한 스크립트가 위치

<br>

### 셸에서 사용되는 특수 문자

- 메타 문자
  - `~(tilde)`: 홈 디렉터리를 나타냄 (~+: 현재 디렉터리)
  - . : 현재 디렉터리를 나타내거나 명령행 맨 앞에서 source라는 의미로 셸 스크립트 등을 실행시킬 때 사용
  - .. : 부모 디렉터리
  - ‘ ‘ : 모든 문자나 특수 문자들을 일반 문자 취급
  - “ “ : $, `, \를 제외한 모든 문자들을 일반 문자로 취급, !(history)도 예외로 인정
  - ` `` `  : 명령 대체 기능 수행
  - `#`: 주석
  - $ : shell 변수 기호로 뒤에 오는 문자열을 변수로 취급
  - & : 특정 명령을 background 작업으로 실행할 때 사용
  - - : 아무것도 없는 경우를 포함한 모든 문자
  - ? : 한 문자를 대체할 때 사용, 특정 명령에 대한 결과를 갖는 return 변수로도 쓰임(셸 상에서 내린 명령의 에러 유무 확인)
  - ( ) : 하나의 셸 단위로 묶어줌
  - \ : 바로 다음에 오는 특수 문자의 기능을 없앰, alias가 설정된 명령어 앞에 사용하는 경우 alia를 없앰, 긴 명령행 입력 시 행을 연장할 때도 사용
  - `[ ]` : 내부에 선택할 수 있는 문자를 나열하여 ~중의 하나로 표현됨, 범위 지정 시 - 사용
  - ; : 명령어를 순차적으로 실행할 때 사용
  - { } : 내부에 제시된 문자열 중 하나로 대치
  - / : 디렉터리 경로 분리자
- 인용 부호: 메타 문자가 가지고 있는 특수한 기능을 제거할 때 사용
  - $
  - ‘ ‘
  - “  “
  - \
  - ` `` `

<br>

## 2.4.2 Shell 프로그래밍

### 셸 프로그래밍의 개요

셸 스크립트 작성법

1. 파일 생성
2. 첫 번째 줄에는 사용할 셸 명시 ex. #/bin/bash
3. 두 번째 줄부터 원하는 명령 및 구문 입력
4. 스크립트 실행 권한 부여
5. 실행

<br>

셸 스크립트 실행

- 경로 등록

  셸 스크립트 실행 시 반드시 경로를 붙여야 함, 현재 디렉터리에 있는 파일 실행 시 ./를 붙여야 함

  붙이지 않는 경우 PATH에 등록된 디렉터리만 검색함

- 허가권 없이 셸 스크립트 실행

  - 앞 부분에 sh 명령 붙이기
  - 앞 부분에 source 명령 붙이기
  - 앞 부분에 . 붙이기

<br>

### 셸 프로그래밍 문법

- 변수: 셸에서 변수는 string만을 가짐

  변수 사용 시 대입연산자, 연산자/피연산자 사이에 공백이 존재해서는 안됨

  <br>

  기타 변수 대응법

  - ${name}: name이라는 변수에 들어있는 값으로 치환
  - ${name:=value}: name이 null이면 value를 name에 저장하고 값이 있으면 해당 값 사용
  - ${name:+value}: 기존의 name이 null이 아니면 value를 사용하지만 name에 저장하지는 않음(일회성)
  - ${name:-value}: 기존에 name 값이 있다면 그 값을 사용하고 없으면 value 값을 대입, name에 value 값을 저장하지는 않음
  - ${name:?value}: 기존에 name 값이 있다면 기본값으로 하고 값이 없으면 error를 내며 value 값을 보여줌
  - ${#name}: name의 문자열 길이 반환
  - ${name:offset}: name 값에서 offset만큼 삭제한 후 값 반환
  - ${name:offset:length}: name 값에서 offset만큼 삭제한 후 length만큼 센 뒤 값 반환

  <br>

  관련 환경 변수

  - $IFS: 입력 필드 구분자로서 셸 상에서 입력을 읽어들일 때 글자를 구분하기 위한 목적으로 사용되는 문자 목록

  <br>

  아규먼트 변수(위치 매개 변수)

  - $0: 실행된 셸 스크립트명
  - $1: 스크립트에 넘겨진 첫 번째 아규먼트
  - $2: 스크립트에 넘겨진 두 번째 아규먼트
  - $#: 스크립트에 넘겨진 아규먼트의 개수
  - $$: 셸 스크립트의 PID
  - $*: 스크립트에 전달된 인자 전체를 하나의 변수에 저장하면 IFS 변수의 첫 번째 문자로 구분
  - $@: $*와 동일하나 IFS 환경 변수를 사용하지 않음
  - $?: 실행한 뒤 반환값, 참: 0, 거짓: 1
  - $-: 현재 셸이 호출될 때 사용한 옵션들

  <br>

  shell 변수 관련 명령어

  - set: 일반적으로 셸 변수 출력, 리눅스에서는 셸의 환경과 관련된 변수, 함수 등도 출력
  - env: 환경 변수 출력, 사용자가 선언한 셸 변수 정보도 출력
  - export: 특정 변수의 범위를 환경 데이터 공간으로 전송하여 자식 프로세스에서도 특정 변수를 사용 가능하게 함(전역)
  - unset: 선언된 변수 제거

- echo문과escape 문자

  echo문: 라인을 제어하는 명령 해석기

  escape 문자

  - \f: 앞 문자열만큼 열을 밀어 이동
  - \n: 새로운 줄로 바꿈
  - \r: 앞 문자열의 앞부분부터 뒷 문자열만큼 대체하고 반환
  - \t: 탭만큼 띄움
  - \\: \를 표기

- 간단한 조건식

  - test 표현식: 명령행에서 간단히 비교를 위해 사용

    ```bash
    test 표현식
    [ 표현식 ]
    # [와 ] 사이에는 반드시 공백이 들어가야 함
    
    ## 문자열 비교 표현식 ##
    # [ string ]: string이 빈 문자열이 아니라면 참
    # [ string1 = string2 ]: 같으면 참
    # [ string1 != string2 ]: 다르면 참
    # [ -n string ]: 문자열이 null이 아니면 참
    # [ -z string ]: 문자열이 null이면 참
    
    ## 산술 비교 표현식 ##
    # [ expr1 -eq expr2 ]
    # [ expr1 -ne expr2 ]
    # [ expr1 -gt expr2 ]: expr1 > expr2
    # [ expr1 -ge expr2 ]: expr1 >= expr2
    # [ expr1 -lt expr2 ]: expr1 < expr2
    # [ expr1 -le expr2 ]: expr1 <= expr2
    # [ !expr ]
    # [ expr1 -a expr2 ]: AND
    # [ expr1 -o expr2 ]: OR
    
    ## 파일 조건 표현식 ##
    # [ -b FILE ]: 파일이 블록 디바이스면 참
    # [ -c FILE ]: 파일이 문자 디바이스면 참
    # [ -d FILE ]: 파일이 디렉터리면 참
    # [ -e FILE ]: 파일이 존재하면 참
    # [ -f FILE ]: 파일이 존재하고 정규 파일이면 참
    # [ -g FILE ]: 파일에 SGID가 있으면 참
    # [ -k FILE ]: 파일에 Sticky bit가 있으면 참
    # [ -L FILE ]: 파일이 심볼릭 링크면 참
    # [ -p FILE ]: 파일이 named pipe면 참
    # [ -r FILE ]: 현재 사용자가 읽을 수 있는 파일이면 참
    # [ -s FILE ]: 파일이 비어 있지 않으면 참
    # [ -S FILE ]: 소켓 디바이스면 참
    # [ -t FD ]: FD가 열려진 터미널이면 참
    # [ -u FILE ]: 파일에 SUID가 있으면 참
    # [ -w FILE ]: 현재 사용자가 쓸 수 있는 파일이면 참
    # [ -x FILE ]: 현재 사용자가 실행할 수 있는 파일이면 참
    # [ -O FILE ]: 파일의 소유자가 현재 사용자면 참
    # [ -G FILE ]: 파일의 그룹이 현재 사용자의 그룹과 같으면 참
    # [ FILE1 -nt FILE2 ]: FILE1이 FILE2보다 새로운 파일이면 참
    # [ FILE1 -ot FILE2 ]: FILE1이 FILE2보다 오래된 파일이면 참
    # [ FILE1 -ef FILE2 ]: I-node 값이 같으면 참
    ```

- 조건문

  - if문: 참이라면 then 부분 실행, if로 시작하면 반드시 fi로 끝내야 함
  - case문: 오른쪽 괄호와 세미콜론을 반드시 사용해야 하며 esac로 끝내야 함
  - select문: Korn Shell 및 Bash만 존재하는 구문으로 간단히 나열 시 사용

- 반복문

  - for문
  - while문
  - until문: while문과 동일한 효과를 내지만 조건이 반대(거짓일 동안 루프 수행)

- 함수

- 패턴과 패턴 비교

  - ${variable#pattern}: 처음부터 pattern과 맞는 variable 부분을 찾아 가장 작은 부분을 제거하고 나머지를 반환
  - ${variable##pattern}: 처음부터 pattern과 맞는 variable 부분을 찾아 가장 큰 부분을 제거하고 나머지를 반환
  - ${variable%pattern}: 끝에서부터 pattern과 일치하는 variable의 최소 부분을 제거하고 나머지를 반환
  - ${variable%%pattern}: 끝에서부터 pattern과 일치하는 variable의 최 부분을 제거하고 나머지를 반환

<br>

### 셸 프로그래밍 기타 사항

- 종료 코드
  - 0: 성공
  - 1: 일반적 오류
  - 2: 셸 내장 명령의 틀린 사용
  - 126: 파일이 실행 가능하지 않음
  - 127: 명령어를 찾을 수 없음
  - 128: 종료할 때 잘못된 인수 적용
  - 128+n: 치명적인 시그널 n 에러
  - 130: ctrl+c 조합에 의한 종료
- 우선순위
  - alias
  - 지정 키워드(function, if 등)
  - 함수
  - 내장 명령어(type, export 등)
  - 스크립트, 프로그램, PATH 환경 변수에 들어있는 디렉터리를 셸이 확인하여 실행

<br>

### 셸 프로그래밍 관련 명령어

- read: 임의의 값을 키보드로부터 입력받는 명령어로 여러 개의 값을 받을 수 있음

  ```bash
  read 변수1 [변수2, ...]
  ```

- echo: 해당 문자열을 표준 출력에 표시하고 행을 바꿈

  ```bash
  echo [option] [문자열]
  
  ## 주요 옵션 ##
  # -n: 출력 결과에서 행 바꿈을 하지 않음
  # -e: escape 문자를 사용할 수 있게 해 줌
  ```

- break: 반복문에서 빠져나옴

  ```bash
  break [n] # 반복문의 n번째 루프에서 빠져나옴
  ```

- continue: 반복문을 계속해서 실행

  ```bash
  continue [n]
  ```

- exit: 상태코드 n과 함께 스크립트를 종료 (n은 성공(0) 또는 실패(0이 아닌 숫자)이며 n이 주어지지 않으면 가장 최근에 사용된 명령의 상태코드 사용)

  ```bash
  exit [n]
  ```

- function: 함수를 정의

  ```bash
  function 함수명
  {
  	명령어
  }
  ```

- getopts: 주로 반복문에서 사용되며 명령행 옵션이 표준 형식에 맞는지 확인, 적합한 옵션들은 하나씩 처리되어 지정된 변수명에 저장됨

  ```bash
  getopts 문자열 변수명
  ```

- return: 함수정의에서 사용되며 함수가 종료될 때 상태코드 n 반환 (n이 생략되면 직전에 실행된 명령 상태 코드 반환)

  ```bash
  return [n]
  ```

- set: 셸에서 변수와 값을 선언할 때 주로 사용하며 옵션 없이 입력하면 셸 변수와 값 출력 c-shell에서는 반드시 사용해야 하나 bash에서는 생략 가능 셸에서 매개인자를 설정하고 다양한 셸 환경 설정 시에도 사용

  ```bash
  set [option] [문자열]
  
  ## 주요 옵션 ##
  # -f: 셸에서 와일드카드 문자를 이용한 확장을 없앰 (= -o nogiob)
  # -C: 리다이렉션 기호인 >를 이용한 파일의 덮어쓰기를 제한 (= -o nociobber)
  # -o: bash의 환경 설정 관련 값을 확인하고 설정하는 옵션
  ```

- shift: 위치 매개변수를 이동할 때 사용, 매개변수 검색 시 자주 사용

  ```bash
  shift [n] # 위치 매개변수를 n만큼 이동(default 1)
  ```

- source: 지정한 텍스트 파일의 내용을 읽고 실행 (.와 같은 기능)

  ```bash
  source 파일 [인수]
  . 파일 [인수]
  ```

- eval: 인자의 값을 구하고 만약 값이 실행 명령어와 같은 문자열인 경우 해당 명령 실행

- expr: 인자로 사용되는 표현식의 값을 구할 때 사용하며 산술연산 가능 셸 상태에서 명령어로도 사용 가능 (단, 셸 상대에서는 * 사용 시 \를 앞에 붙여서 사용해야 하고, 값과 연산자 사이는 반드시 한 칸 띄어야 함)

  ```bash
  expr 값 연산자 값
  ```

- printf: 최근에 등장한 shell에서만 사용 가능하며 형식화된 출력을 할 때 사용, C언어의 printf() 함수와 유사

  ```bash
  printf "format string" parameter1 parameter2
  
  ## 주요 format ##
  # %d: 십진수 출력
  # %c: 한 문자 출력
  # %s: 문장 출력
  # %%: % 문자 출력
  ```

- true: 셸에서 참값인 0을 반환, Bourne shell에서 :로 같은 효과를 얻을 수 있음

- type: 주어진 인자가 셸 스크립트, 함수, 앨리어스인지 검사하여 출력, 기본적으로 함수이면 정의된 내용까지 출력하고 명령어에도 검사 가능

  ```bash
  type [option] 인자
  
  ## 주요 옵션 ##
  # -all: 지정한 인자 이름으로 정의된 모든 정보 출력
  # -path: 실행 파일이나 셸 스크립트에 한정하여 관련 정보 출력
  # -type: 인자 이름과 일치하는 키워드 하나만 출력
  ```

<br>

# 2.5 프로세스

## 2.5.1 프로세스의 개념 및 종류

### 프로세스(Process)의 정의

1. 실행 중인 프로그램으로 실행 시 번호(PID)가 할당되어 관리됨
2. PCB를 지닌 프로그램
3. 프로그램 카운터를 지닌 프로그램
4. 능동적 개체로 순차적으로 수행하는 프로그램

<br>

### 프로세스의 생성

- fork: 새로운 프로세스를 위해 메모리를 할당받아 복사본 형태의 프로세스를 실행하는 형태, 기존의 프로세스는 그대로 실행되어 있음
- exec: 원래의 프로세스를 대체하는 형태로 호출한 프로세스의 메모리에 새로운 프로세스의 코드를 덮어씌움, 새로운 프로세스를 위한 메모리를 할당하지 않음

리눅스 부팅 시 커널이 systemd라는 최초의 프로세스를 발생시키고 systemd는 PID 1번을 할당받음

그 후 다른 프로세스들은 fork 방식으로 systemd의 자식 프로세스로 생성됨

<br>

### 프로세스의 종류

- 백그라운드 프로세스: 사용자의 입력에 관계없이 실행(포어그라운드 프로세스 실행 명령 뒤에 &을 붙여 실행)
- 포어그라운드 프로세스: 명령 입력 후 수행 종료까지 기다려야 함

<br>

### 멀티태스킹과 작업 전환

- 포어그라운드 → 백그라운드 전환: ctrl + z로 작업 중인 프로세스 대기

  ```bash
  jobs # 작업 상태 확인
  bg # 일시적으로 중단된 상태에서 백그라운드 프로세스로 전환
  ```

- 백그라운드 → 포어그라운드 전환

  ```bash
  fg # 가장 늦게 실행한 프로세스로 전환
  fg [%작업번호]
  fg [작업번호]
  ```

<br>

jobs 명령 실행 시 표시되는 +, - 기호

- +: 주로 처리되는 프로세스(가장 늦게 실행한 프로세스)
- -: + 기호가 붙은 작업의 다음 우선순위 작업

<br>

## 2.5.2 프로세스 관리의 이해

### IPC(Inter-Process Communication)

IPC: 프로세스들 사이에 서로 데이터를 주고받는 행위 또는 그에 대한 방법이나 경로를 통칭하는 말

IPC 방식에는 파일, 신호, 소켓, 메시지큐 등이 있음

<br>

### 시그널(Signal)

특정 프로세스가 다른 프로세스에게 메시지를 보낼 때 사용

kill -l로 시그널 목록을 확인 가능하며 번호로 관리됨

<br>

일반적으로 사용되는 시그널

| 번호                                                         | 이름          | 의미                                                         |
| ------------------------------------------------------------ | ------------- | ------------------------------------------------------------ |
| 1                                                            | SIGHUP(HUP)   | Hangup의 약어로 로그아웃과 같이 터미널에서 접속이 끊겼을 때 보내지는 시그널 |
| 데몬 관련 환경 설정 파일을 변경시키고 변화된 내용을 적용하기 위해 재시작할 때 사용됨 |               |                                                              |
| 2                                                            | SIGINT(INT)   | 키보드로부터 오는 인터럽트 시그널로 실행을 중지시킴          |
| ctrl + c 입력 시 보내짐                                      |               |                                                              |
| 3                                                            | SIGQUIT(QUIT) | 키보드로부터 오는 실행 중지 시그널                           |
| ctrl + w 입력 시 보내짐                                      |               |                                                              |
| 9                                                            | SIGKILL(KILL) | 프로세스 강제 종료 시그널                                    |
| 15                                                           | SIGTERM(TERM) | Terminate의 약자로 가능한 정상 종료시키는 시그널             |
| kill 명령의 기본 시그널                                      |               |                                                              |
| 18                                                           | SIGCONT(CONT) | Continue 시그널로 정지된 프로세스를 다시 실행시킬 때 사용    |
| 19                                                           | SIGSTOP(STOP) | 터미널에서 입력된 정지 시그널                                |
| 20                                                           | SIGTSTP(TSTP) | 실행 정지 후 다시 실행을 계속하기 위해 대기시키는 시그널     |
| ctrl + z 입력 시 보내짐                                      |               |                                                              |

<br>

### 데몬(daemon)

주기적이고 지속적인 서비스 요청 처리를 위해 계속 실행되는 프로세스로 백그라운드로 실행됨

<br>

데몬 프로세스 실행 방법

- standalone: 부팅 시 실행되어 해당 프로세스가 메모리에 계속 상주하며 클라이언트의 서비스 요청 처리

- inetd: 클라이언트의 서비스 요청이 들어왔을 때 관련 프로세스를 실행시키고 접속 종료 후에는 자동으로 프로세스를 종료시키는 방식

  inetd 데몬만 메모리에 상주하고 inetd 데몬이 관리하는 서비스에 대한 요청이 들어오면 해당 프로세스 실행

  커널 2.4 버전부터는 xinetd 데몬이 해당 역할 수행, 최근에는 리눅스 시스템의 메모리 용량이 커지면서 xinetd 기반의 데몬 실행보다 단독 데몬으로 실행하는 경우가 늘고 있음

<br>

### 데몬의 실행

보통 부팅 시 실행됨

- CentOS 6 이전 버전: System V 계열의 init 스크립트 사용
- CentOS 7부터: systemd 기반 (systemctl 명령 이용)

<br>

### 데몬 관련 유틸리티

- ntsysv: 텍스트 환경에서 커서를 이용하여 부팅 중 자동을 실행되는 서비스를 설정할 수 있는 유틸리티

  ntsysv 대신 setup 입력 후 나타나는 메뉴 항목에서 System services를 선택해도 됨

  ```bash
  ntsysv [option]
  
  ## 주요 옵션 ##
  # --level 실행레벨: 특정 실행레벨 편집
  ```

- chkconfig: System V 기반의 init 스크립트 시절 사용하던 텍스트 기반의 명령형 프로그램으로 실행레벨에 따른 서비스의 on/off 설정 리스트를 출력하거나 설정함

  systemd 기반으로 전환된 이후에는 System V 기반의 일부 서비스와 xinetd 기반 서비스만 제어 가능
