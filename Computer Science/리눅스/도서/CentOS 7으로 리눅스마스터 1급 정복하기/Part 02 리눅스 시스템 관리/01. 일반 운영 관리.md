# 일반 운영 관리

# 1.1 사용자 관리

## 1.1.1 root(Super User) 관리

### 사용자(User)의 개요

- 사용자의 분류
  - root: = Privileged User, Super User, 시스템 운영에 있어서 모든 권한 행사 (UID 0)
  - 일반 사용자: = Normal User, Unpriviledge User, 제한적 권한 행사
    - 로그인이 가능한 사용자
    - 시스템 계정

<br>

시스템 계정: 시스템의 필요에 의해 생성된 계정으로 프로그램 실행 시 권한 관련 문제점을 줄이기 위해 생성됨

사용자 계정 정보는 /etc/passwd 파일에 기록되며, 해당 파일에서 UID와 GID가 0인 유저가 슈퍼 유저가 됨

<br>

root 계정 관리 시 주의 사항

1. root 계정 이외에 다른 슈퍼유저가 존재하는지(UID가 0인지) 점검
2. PAM을 이용하여 root 계정으로 직접 로그인하는 것을 막음
3. 일반 계정으로 로그인하여야 하며 root 권한이 필요한 su 명령을 사용
4. TMOUT을 설정하여 장시간 로그인하지 않도록 함
5. 일반 사용자에게 특정 명령어 권한만 할당하는 경우 su 대신 sudo 사용

<br>

## 1.1.2 사용자 계정 관리

### 사용자 계정 생성

```bash
useradd [option] 사용자계정이름

## 주요 옵션 ##
# -p: 사용자의 암호 추가 시 지정 가능
# -d: 홈 디렉터리 지정, 최종 디렉터리만 생성
# -g: 그룹을 지정할 때 사용, 지정할 그룹이 미리 생성되어 있어야 함(지정하지 않는 경우 레드햇 계열에서는 아이디와 동일한 그룹에 포함, 다른 배포판에서는 users에 포함)
# -G: 기본 그룹 이외에 추가로 그룹에 속하게 할 경우 사용
# -c: 사용자 생성 시 사용자에 대한 설명 설정
# -s: 사용자 생성 시 사용자가 이용할 셸 설정
# -D: /etc/default/useradd에 설정된 유저 추가와 관련된 기본 사항들을 보여줌
# -m: 사용자 생성 시 홈 디렉터리 생성, 레드햇 리눅스를 제외한 배포판에서는 자동으로 홈 디렉터리가 생성되지 않기 때문에 지정해 주어야 함
# -k: 사용자 생성 시 제공되는 환경 파일들은 기본적으로 /etc/skel로 지정되어 있는데 이 외의 디렉터리 지정 시 사용
# -f: 패스워드 만기일을 날짜수로 지정
# -e: 계정 만기일을 YYYY-MM-DD 형식으로 지정
# -u: UID 값 지정
# -h: useradd 명령어의 사용법 및 주요 옵션 화면 출력
```

<br>

### 사용자 암호 부여

리눅스에서 useradd로 계정 생성 후 암호를 지정하지 않으면 로그인이 되지 않음

root만 다른 사용자의 암호 변경 가능

```bash
passwd [사용자명]
```

<br>

### 사용자 전환

다른 사용자의 권한으로 셸을 실행할 수 있도록 전환

```bash
su [option] [사용자명] # 사용자명을 입력하지 않는 경우 root로 전환

## 주요 옵션 ##
# -, -l: 전환하려는 사용자의 환경 변수 값을 가지고 전환함, 해당 옵션 없이 실행하는 경우 로그인한 사용자의 환경 변수 값을 가지고 다른 사람의 권한만을 가짐
# -c: 사용자를 전환하지 않고 다른 사용자의 권한으로 명령을 일시적으로 수행
```

<br>

### 사용자 관련 파일 및 디렉터리

- /etc/passwd: 사용자의 목록을 저장하고 있는 파일

  사용자명:패스워드:UID:GID:fullname:home-directory:shell

- /etc/shadow: /etc/passwd의 패스워드를 암호화하여 관리하는 파일

  사용자명:패스워드:최근 패스워드 변경일:패스워드 변경 후 최소 사용 날짜수:패스워드의 유효기간:사용기한 만료 전 경고 기간:사용한 만료 후 유예기간:계정만기일:공백

  패스워드 관리를 /etc/passwd에서 하려면 `pwunconv` 명령 입력

  /etc/shadow에서 하려면 `pwconv` 명령 입력

  pwck: 사용자 관련 파일인 /etc/passwd, /etc/shadow 점검 명령

- /etc/default/useradd: useradd로 계정 생성 시 기본적으로 적용되는 설정이 들어있는 파일

- /etc/login.defs: 메일 디렉터리, 패스워드 관련 설정, UID/GID의 최대값, 최소값 등이 정의되어 있음

- /etc/skel: 사용자 생성 시 기본적으로 제공되는 파일이나 디렉터리 위치

<br>

### 사용자 계정 관리

```bash
usermod [option] 사용자계정

## 주요 옵션 ##
# -d: 사용자의 홈 디렉터리 변경
# -m: 홈 디렉터리 변경 시 기존에 사용하던 파일 및 디렉터리 이동, -d와 함께 쓰임
# -g: 사용자의 그룹 변경
# -s: 사용자의 셸 변경
# -u: 사용자의 UID 값 변경
# -e: 계정만기일 변경(YYYY-MM-DD 또는 MM/DD/YY 형태로 지정)
# -f: 패스워드 만기일이 지난 후 패스워드에 Lock을 설정할 유예 기간 지정
# -c: 사용자의 간단한 정보를 입력하거나 변경
# -G: 추가로 다른 그룹에 속하게 하는 경우 사용
# -a: -G 옵션과 같이 사용되며 기존의 2차 그룹 이외에 추가로 2차 그룹 지정 시 사용
# -p: 암호화된 패스워드 값 변경 시 사용, 암호화된 값으로 지정
# -l: 사용자 아이디 변경
# -L: 사용자의 패스워드에 잠금을 걺
# -U: 패스워드에 설정된 잠금을 풂
```

<br>

### 사용자 계정 삭제

```bash
userdel [option] 사용자계정

## 주요 옵션 ##
# -r: 사용자의 홈 디렉터리 및 메일 관련 파일까지 제거
```

<br>

### 사용자 패스워드 관리 1

패스워드를 부여/변경

```bash
passwd [option] 사용자계정

## 주요 옵션 ##
# -S: 패스워드 정보 출력
# -l: 패스워드 잠금
# -u: 패스워드 잠금 해제
# -d: 패스워드를 제거하여 패스워드 없이 로그인할 수 있도록 함
# -n: 패스워드 변경 후 최소로 사용해야 하는 날짜 수 설정
# -x: 패스워드의 유효 기간 지정
# -w: 패스워드 만료 전 경고 날짜 지정
# -i: 패스워드 만료 후 실제 로그인이 불가능하기까지 유예 기간 설정
# -e: 다음 로그인 시 반드시 패스워드를 변경하도록 함(/etc/shadow의 세 번째 필드 값이 0으로 설정됨)
```

<br>

### 사용자 패스워드 관리 2

사용자 패스워드에 대한 정보 출력, 설정

```bash
change [option] 사용자계정

## 주요 옵션 ##
# -l: 사용자 패스워드 정보를 보여줌
# -d: 최근 패스워드를 바꾼 날 수정
# -m: 패스워드 변경 후 사용해야 하는 최소 날짜수 지정
# -M: 패스워드의 만기일 지정
# -I: 패스워드 만료 기한 이후 잠금을 설정하기까지 유예 기간 지정
# -E: 계정 만기일 지정
# -W: 패스워드 만료 전 변경을 요구하는 경고 날짜 지정
# -h: 명령어의 사용법 및 주요 옵션 정보 출력
```

<br>

### chpasswd

사용자 패스워드 변경 명령어로 주로 여러 사용자들의 패스워드를 한 번에 변경하는 경우 사용

```bash
chpasswd [option] [ < 파일] # '사용자명:암호' 형태로 지정

## 주요 옵션 ##
# -e: 암호화된 패스워드 값을 사용할 경우 지정
# -c: 패스워드에 사용할 암호화 알고리즘 지정
# -m: 암호화 알고리즘으로 MD5를 사용할 때 지정
```

<br>

## 1.1.3 그룹 계정 관리

### 그룹의 개요

사용자 간 파일을 공유할 때 묶어 허가권 설정을 통해 공유하도록 하는 것

리눅스에서 모든 사용자는 하나 이상의 그룹에 반드시 속함

<br>

### 그룹의 조회

등록된 그룹 목록은 `/etc/group`에서 확인 가능

GroupName:Password:GID:MemberList

그룹 패스워드의 경우 `/etc/gshadow`에서 관리

GroupName:Password:그룹관리자:MemberList

패스워드 관리를 `/etc/group`에서 하고 싶은 경우 `grpunconv` 명령어로 가능

취소 시 `grpconv`

`/etc/group`과 `/etc/gshadow`를 점검하려면 `grpck` 명령어 사용

<br>

### 그룹 생성

```bash
groupadd [option] 그룹명 # root만 사용 가능

## 주요 옵션 ##
# -g: 생성과 동시에 GID 부여
# -r: 생성하는 그룹을 시스템 그룹으로 생성
```

<br>

### 그룹 변경

```bash
groupmod [option] 그룹명

## 주요 옵션 ##
# -n: 그룹 이름 변경
# -g: 그룹의 GID 변경
```

<br>

### 그룹 삭제

```bash
groupdel 그룹명 # 그룹에 속한 사용자가 없는 경우에 삭제 가능
```

<br>

### gpasswd

그룹의 패스워드를 설정하거나 그룹 관리자를 지정

그룹 관리자의 경우 해당 그룹에 속하지 않아도 됨

```bash
gpasswd [option] group

## 주요 옵션 ##
# -A: root가 그룹 관리자 지정 시 사용
# -a: 그룹 관리자가 그룹에 사용자 추가 시 사용
# -d: 그룹 관리자가 사용자 제외 시 사용
# -r: 그룹 패스워드 제거
# -R: 그룹 패스워드의 사용을 비활성화
# -M: root가 그룹 멤버 지정 시 사용
```

<br>

### newgrp

사용자가 일시적으로 1차 그룹 변경 시 사용

해당 그룹에 속한 경우 패스워드 입력 없이 변경 가능

원래 그룹으로 돌아가려면 exit 입력

```bash
newgrp 그룹
```

<br>

## 1.1.4 사용자 관련 명령어

### users

시스템에 로그인되어 있는 사용자의 아이디 출력

```bash
users
```

<br>

### who

시스템에 로그인되어 있는 사용자 출력

```bash
who [option]

## 주요 옵션 ##
# -b: 시스템의 부팅 시간 출력
# -d: 죽은 프로세스 출력
# -H: 출력되는 정보의 헤더 출력
# -l: 시스템 로그인 프로세스 출력
# -p: init 프로세스에 의해 발생되어 활성화된 프로세스 출력
# -r: 현재의 런레벨 출력
# -t: 마지막으로 시스템 시간이 변경된 정보 출력
# -T: 사용자의 메시지 상태 출력
# -u: 시스템에 로그인한 사용자의 목록 출력
# -m: 표준 입력과 연관된 호스트명과 사용자명 출력 (= who am i)
# -a: -b, -d, -l, -p, -r, -t, -T, -u를 통합한 옵션
```

<br>

### whoami

실질적으로 사용 중인 권한자 출력

```bash
whoami
```

<br>

### w

시스템에 로그인되어 있는 사용자와 사용자가 수행 중인 작업 출력

```bash
w [option] [user]

## 주요 옵션 ##
# -h: 헤더를 출력하지 않음
# -s: 간략히 출력
```

<br>

### logname

사용자의 로그인 계정 출력

```bash
logname
```

<br>

### id

시스템에 등록된 아이디에 대한 정보 출력(UID, GID, 속한 그룹 정보)

```bash
id [option] [user]

## 주요 옵션 ##
# -g: 주 그룹의 GID만 출력
# -G: 속한 모든 그룹의 GID 출력
# -u: 사용자의 UID만 출력
# -n: -u나 -g 옵션과 같이 사용되며 숫자값 대신 이름으로 출력
```

<br>

### groups

속한 그룹명 출력

```bash
groups [user]
```

<br>

### lslogins

시스템 전체 사용자의 정보 출력(로그 파일에서도 관련 정보를 가져옴)

```bash
lslogins [option]

## 주요 옵션 ##
# -G: 각 사용자의 그룹 정보 출력
# -L: 각 사용자의 마지막 로그인 정보 출력
# -u: 사용자의 계정 정보 출력, 일반적으로 시스템 계정을 제외하고 실제 로그인이 되는 계정 위주로 관련 정보 출력
```

<br>

### write

로그인한 다른 사용자에게 메시지를 보냄

```bash
write 사용자계정 [ttyname] # 명령 실행 후 메시지를 입력하고 ctrl + d 입력 시 전송됨
# ttyname은 동일한 사용자가 여러 곳에서 로그인한 경우 사용
```

<br>

### wall

로그인한 모든 사용자의 터미널에 메시지 전송

```bash
wall [메시지]
```

<br>

### mesg

write를 사용해 들어오는 메시지 수신 여부를 확인, 제어

```bash
mesg [n | y]
```

<br>

### mail

시스템 사용자 간에 전자우편함을 통해 메시지를 주고받거나 확인

전자우편함 경로: 홈 디렉터리 또는 /var/spool/mail/사용자계정

```bash
mail [option] [사용자계정]

## 주요 옵션 ##
# -s <제목>: 메일을 보낼 때 제목 지정

## 메일 확인 관련 주요 명령 ##
# r [메일번호]: 답장을 보냄
# d 메일번호: 지정한 메일 삭제
# n: 다음 차례 메일 확인
# q: 메일 확인 모드 종료
# s 파일명: 메일의 내용을 지정한 파일명으로 저장
```

<br>

# 1.2 파일 시스템 관리

## 1.2.1 파일 및 디렉터리 관리

### 소유권과 허가권

소유권(Ownership): 어떤 파일이나 디렉터리를 소유하는 권리

사용자 소유권과 그룹 소유권으로 나눔

허가권(Permission): 파일이나 디렉터리에 접근 권한을 설정하는 권리, 일반적으로 소유권을 가진 사용자가 허가권을 설정

사용자, 그룹, 다른 사용자로 나누어 설정함

`ls -l` 명령으로 권한 설정 확인 가능

<br>

허가권의 영역

​	`----------` 10개 영역으로 나누어짐

​	첫 번째 영역: 파일의 타입

​	첫 세 자리: 파일을 소유한 사용자에게 적용되는 권한

​	두 번때 세 자리: 해당 그룹에 속한 사용자들에게 적용되는 권한

​	마지막 세 자리: 그 외의 다른 사용자들에게 적용되는 권한

<br>

권한 표시 방법

| 권한 | 파일                              | 디렉터리                                             |
| ---- | --------------------------------- | ---------------------------------------------------- |
| r    | 파일의 내용을 볼 수 있는 권한     | 디렉터리 내부의 내용을 볼 수 있는 권한               |
| w    | 파일의 내용을 수정할 수 있는 권한 | 디렉터리 내부에 파일을 생성 또는 삭제할 수 있는 권한 |
| x    | 실행 파일을 실행시킬 수 있는 권한 | 디렉터리 내부로 접근할 수 있는 권한                  |
| -    | 권한 없음                         | 권한 없음                                            |

<br>

### 특수 권한

- Set-UID: 보통 실행 파일에서 사용되며 Set-UID가 부여된 파일 실행 시 해당 파일을 실핸하는 동안에는 사용자의 권한이 아니라 해당 파일 소유자 권한으로 인식함

  설정 시 소유자 권한 부분의 x 자리가 s로 표시됨 (실행 권한이 없는 파일에 부여하는 경우 대문자 S로 표시됨)

- Set-GID: 주로 디렉터리에 설정되며 파일에 설정되어 있는 경우 해당 파일을 소유한 그룹 권한으로 인식함

  해당 권한 설정 디렉터리에 파일이나 디렉터리를 생성하면 해당 사용자가 속한 그룹에 상관없이 디렉터리 소유 그룹 권한으로 만들어짐

  설정 시 그룹 소유권 부분의 x 자리가 s로 표시됨 (실행 권한이 없는 경우 대문자 S로 표시됨)

- Sticky-Bit: 디렉터리에 설정되는 특수 권한으로 일종의 공유 디렉터리로 사용됨 (/tmp 디렉터리에 기본으로 설정되어 있음)

  해당 설정 사용 시 공유 폴더라도 본인이 생성한 파일만 삭제 가능

  Group과 Other 계층 사용자에게 사용할 수 있으나 두 계층 함께 사용은 불가능

  설정 시 other 계층 권한 부분의 x 자리가 t로 표시됨 (실행 권한이 없는 경우(그룹의 공유 모드로 사용한 경우) 대문자 T로 표시됨)

<br>

특수 권한 설정 시 `chmod` 명령 사용

- 문자 모드: Set-UID, Set-GID는 s, Sticky-bit은 t 사용
- 숫자 모드: 천의 자리가 사용되며 Set-UID는 4, Set-GID는 2, Sticky-bit은 1의 값을 가짐

<br>

### 소유권 및 허가권 관련 명령어

- chmod: 파일이나 디렉터리에 접근할 수 있는 허가권 설정

  - 문자 모드: 권한은 r, w, x로 표시, 사용자 지정은 u, g, o, a를 사용, 설정 기호는 +, -, = 사용

    u: 파일 소유자의 접근 권한 지정

    g: 그룹 사용자의 접근 권한 지정

    o: 다른 사용자들의 접근 권한 지정

    a: 모든 접근 권한 지정(default)

    +, -: 설정, 해제

    =: 특정 권한만 지정 시 사용

  - 숫자 모드: 4(읽기), 2(쓰기), 1(실행), 0을 조합해 8진수의 값을 만들어 권한을 설정

    두 가지 이상의 권한을 설정하는 경우 가중치 값을 더해 지정

    소유자는 100의 자리, 그룹은 10의 자리, 다른 사용자는 1의 자리에 배치

  ```bash
  chmod [option] mode file(s)
  
  ## 주요 옵션 ##
  # -R: 하위 디렉터리를 포함하여 디렉터리 내부 모든 파일의 접근 권한 변경
  # -c: 변경된 정보 출력
  # -f: 중요한 오류 메시지가 아니면 출력하지 않음 
  # -v: 명령 진행 결과에 대한 정보를 자세히 출력
  # --version: 명령어의 버전 정보 출력
  ```

- chown: 파일이나 디렉터리의 소유권 및 그룹 소유권 변경

  ```bash
  chown [option] owner[:group] file(s)
  
  ## 주요 옵션 ##
  # -R: 하위 디렉터리를 포함하여 디렉터리 내부 모든 파일의 접근 권한 변경
  # -c: 변경된 정보 출력
  # -f: 중요한 오류 메시지가 아니면 출력하지 않음 
  # -v: 명령 진행 결과에 대한 정보를 자세히 출력
  # --version: 명령어의 버전 정보 출력
  ```

- chgrp: 파일이나 디렉터리의 소유 그룹 변경

  ```bash
  chgrp [option] group file(s)
  
  ## 주요 옵션 ##
  # -R: 하위 디렉터리를 포함하여 디렉터리 내부 모든 파일의 접근 권한 변경
  # -c: 변경된 정보 출력
  # -v: 명령 진행 결과에 대한 정보를 자세히 출력
  # -h: 심볼릭 링크 파일의 그룹 소유권 변경 (원본 파일이 아닌 심볼릭 링크 파일 자체의 그룹 소유권 변경)
  # --version: 명령어의 버전 정보 출력
  ```

- umask: 파일이나 디렉터리 생성 시 부여되는 기본 허가권 값을 지정 (숫자, 문자 둘 다 지정 가능)

  옵션과 값 없이 실행 시 설정된 umask 값 확인 가능

  파일 생성 시에는 666, 디렉터리인 경우 777에서 설정한 umask 값을 뺀 값을 기본 허가권으로 지정

  ```bash
  umask [option] [값]
  
  ## 주요 옵션 ##
  # -S: umask 값을 문자로 표기함
  ```

<br>

### 파일 링크

파일 링크의 개요

리눅스에서 파일이나 디렉터리를 생성하면 I-node란는 번호가 임의로 부여되고 해당 번호를 기준으로 관리됨

파일명이 다르더라도 해당 번호가 같다면 같은 파일로 인식

이렇게 하나의 파일을 여러 개의 이름으로 관리하는 형태를 링크라고 부름

<br>

관련 명령어: ln

하드 링크 또는 심볼릭 링크를 생성하는 명령

```bash
ln [option] 원본 대상파일명

## 주요 옵션 ##
# -s: 심볼릭 링크 생성 시 사용(옵션이 존재하지 않는 경우 하드 링크 생성)
# -v: 링크 만드는 정보를 자세히 출력
# -f: 링크 파일 존재 시 삭제 후 생성
```

<br>

하드 링크와 심볼릭 링크

- 하드 링크: 하나의 동일한 파일을 디스크의 다른 곳에 복사하여 여러 이름으로 사용하는 형식, 파일에만 부여 가능

  하드 링크의 특징

  - `ls -i` 명령으로 I-node 번호 확인 시 원본과 링크 파일의 번호가 같음
  - 원본과 링크 파일의 내용과 파일의 크기가 같음
  - `ls -l` 명령 시 출력되는 링크의 숫자가 올라감
  - 원본이나 링크 파일 중에 어떤 파일을 수정해도 같이 반영됨
  - 원본 파일을 삭제해도 링크 파일은 영향을 받지 않음
  - 파일만 설정 가능하며 동일한 파일 시스템에서만 사용 가능
  - 파티션이나 디스크 드라이브를 가로질러 사용할 수 없음

- 심볼릭 링크: 하나의 파일을 여러 이름으로 가리키게 하는 것으로 원본과 생성된 링크 파일은 다른 파일로 관리됨

  파일과 디렉터리 모두 사용 가능하나 일반적으로 디렉터리의 경로 단축이나 변경에 사용됨

  심볼릭 링크의 특징

  - `ls -i` 명령으로 I-node 번호를 확인하면 원본과 생성된 링크 파일의 번호가 다름
  - 생성된 링크 파일의 크기가 매우 작음
  - `ls -l` 명령 시 출력되는 권한 영역의 맨 앞쪽에 1이라고 표시됨
  - 원본이나 링크 파일 중 어떤 파일을 수정해도 같이 반영됨
  - 원본 파일을 삭제하면 링크 파일은 어떤 역할을 하지 못함
  - 디렉터리에 링크 파일을 생성하면 윈도우의 바로가기나 단축 아이콘의 기능과 같아짐
  - 생성되는 링크 파일의 퍼미션 값은 777로 표시되나 원본 파일의 권한과는 무관함

<br>

## 1.2.2 파일 시스템 관리 및 복구

### 파일 시스템 생성

디스크 장착 후 작업

1. 디스크 인식 여부 확인

   `fdisk -l` 명령으로 확인

2. 파티션 작업

   `fdisk 장치명` 명령 실행 후 원하는 용량만큼 할당

3. 시스템 재부팅

   파티션 정보를 업데이트하려면 `partprobe` 명령을 사용하거나 `reboot` 명령으로 재부팅함

   재부팅 후 파티션 활성화 여부는 `/proc/partitions` 파일에서 확인

4. 파일 시스템 생성

5. 디렉터리(마운트 포인트) 생성

6. 마운트 작업

7. 마운트 및 용량 확인

8. 부팅 시 자동 마운트 되도록 /etc/fstab 파일에 등록

<br>

### 관련 명령어

- fdisk: 디스크의 파티션을 확인하고 추가/삭제하는 명령, 설정 후 반드시 재부팅해야 함

  ```bash
  fdisk [option] [장치파일명]
  
  ## 주요 옵션 ##
  # -l [장치파일명]: 지정한 장치 파일의 파티션 테이블 정보 출력 (장치 파일명을 명시하지 않는 경우 /proc/partitions의 정보를 기반으로 장착된 디스크 파티션 테이블 정보 출력)
  # -s partition: 특정 파티션의 크기 출력, 단위는 block
  # -v: fdisk의 버전 출력
  
  ## fdisk 실행 시 주요 명령 ##
  ## fdisk 명령 실행 시 텍스트 기반의 특정 명령어를 입력해야 파티션 설정 가능 ##
  # p: 현재 디스크의 정보 출력
  # d: 파티션 삭제
  # n: 파티션 생성
  # t: 파티션의 속성 변경 
  # w: 변경된 파티션의 정보를 저장하고 종료
  # q: 변경된 파티션의 정보를 저장하지 않고 종료
  ```

- mkfs: 새로운 파일 시스템을 만드는 명령으로 root만 사용 가능

  ```bash
  mkfs [-t fs_type] [option] 장치명
  
  ## 주요 옵션 ##
  # -t fs_type: 파일 시스템의 유형을 지정 (미지정 시 ext2로 생성)
  # -c: 배드 블록을 체크한 후 파일 시스템 구축
  # -v: 결과를 상세하게 출력
  ```

- mke2fs: ext2, ext3, ext4 파일 시스템을 만드는 명령으로 mkfs 명령 실행 시 실제로 사용되는 명령

  ```bash
  mke2fs [option] 장치명
  
  ## 주요 옵션 ##
  # -j: 저널링 파일 시스템인 ext3으로 만듦
  # -t fs_type: 파일 시스템 유형 지정
  # -b block_size: 블록 사이즈 지정
  # -R raid_options: RAID 관련 옵션으로 -R 다음에 argument=값 형태로 지정
  # -T usage_Type: I-node의 크기를 지정하는 옵션
  ```

  최근 리눅스 배포판에서는 파일 시스템 생성 시 명령어 사용법을 간소화할 수 있는 mkfs.ext2 등이 추가로 제공됨

- mkfs.xfs: XFS 파일 시스템을 만드는 명령, mkfs 명령으로 -t xfs 지정 시 해당 명령이 실행됨

  ```bash
  mkfs.xfs [option] 장치명
  
  ## 주요 옵션 ##
  # -b block_size: 블록 사이즈 지정
  # -f: 지정한 디바이스에 파일 시스템이 존재하는 경우 강제로 수행
  ```

- mount: 보조 기억장치나 파일 시스템이 다른 디스크를 /의 하위 디렉터리로 연결하여 사용 가능하게 해 주는 명령

  ```bash
  mount [option] [device] [directory]
  
  ## 주요 옵션 ##
  # -a: /etc/fstab에 명시된 파일 시스템을 마운트할 때 쓰이는 옵션
  # -t fs_type: 파일 시스템의 유형을 지정하는 옵션(미지정 시 /etc/fstab 파일 참조)
  # -o 항목: 추가적인 설정 적용, 다수의 조건 적용 시 ,로 구분
  ```

  - 주요 파일 시스템의 유형
    - msdos
    - vfat
    - ntfs
    - ext2, ext3, ext4
    - xfs
    - iso9660
    - smbfs
    - cifs
    - nfs
    - udf
  - -o의 주요 항목
    - ro: 읽기 전용으로 마운트
    - rw: 읽기/쓰기 모드로 마운트 (default)
    - remount: 파티션의 정보를 바꾸었을 때 해당 파티션을 다시 마운트
    - loop: CD-ROM 이미지 파일인 iso를 마운트해서 사용할 때 사용
    - noatime: 파일이 읽히면 Access Time이 변경되는데, 해당 옵션 사용 시 파일이 변경되기 전까지는 Access Time이 변경되지 않음 → 시스템의 작업을 줄여 성능 향상
    - username=사용자명: 사용자 계정이 필요한 경우 사용
    - password=암호: 패스워드가 설정되어 있는 경우 사용
    - acl: ext3 파일 시스템에서 지원하는 접근 제어 리스트를 사용 가능하도록 마운트할 때 사용
  - 주요 디바이스 파일명
    - FDD: /dev/fd0, /dev/fd1 등
    - CD-ROM, DVD: /dev/cdrom, /dev/dvd, /dev/sr0, /dev/hdc, /dev/sdb 등
    - IDE HDD: /dev/hda1, /dev/hdb1 등
    - USB Memory, SCSI HDD, S-ATA HDD: /dev/sda, /dev/sdb1 등

- umount: 마운트된 파일 시스템을 해제시켜주는 명령 (디스크 제거 시 주로 사용)

  ```bash
  umount [option] 디바이스명
  umount [option] 마운트된_디렉터리명
  
  ## 주요 옵션 ##
  # -a: /etc/mtab에 명시된 파일을 언마운트할 때 사용
  # -t fs_type: 언마운트할 파일 시스템을 지정할 때 사용
  ```

- eject: 이동식 보조 기억 장치의 미디어를 꺼낼 때 사용하는 명령으로 해당 명령 사용 시 자동으로 언마운트 작업 수행

  ```bash
  eject [장치명 or 마운트된_디렉터리명]
  ```

- blkid: 블록 장치의 속성 정보 출력 명령

  ```bash
  blkid [option] [device]
  
  ## 주요 옵션 ## 
  # -L: 라벨명으로 블록 장치를 찾을 때 사용
  # -U: UUID 명으로 블록 장치를 찾을 때 사용
  ```

- lsblk: 블록 장치의 목록 출력 명령

  ```bash
  lsblk [option] [장치명]
  
  ## 주요 옵션 ##
  # -m: 블록 장치의 소유자, 소유 그룹, 허가권 정보 출력
  # -f: 블록 장치의 이름, 파일 시스템 타입, 라벨, UUID, 마운트포인트 정보 출력
  # -o: 명시한 항목에 대한 정보 추가 출력
  ```

<br>

### 관련 파일

- /etc/fstab: 파일 시스템에 대한 정보를 담고 있는 파일로 부팅 시 마운트할 파티션 정보가 기록되어 있음

  파티션 정보를 변경하였거나 디스크를 추가한 경우 해당 파일에 등록해야 부팅 시 자동으로 마운트가 됨

  <br>

  fstab의 필드 구성 (man 5 fstab에서 확인 가능)

  1. 볼륨 라벨이나 UUID가 기록되는 영역 (원래는 장치명이 기록되는 영역이었음), 네트워크로 연결된 호스트인 경우 호스트명:디렉터리 형식으로 표기
  2. 마운트될 디렉터리
  3. 파일 시스템의 유형
  4. 마운트될 때의 옵션
  5. dump 명령을 통한 백업 시 레벨 덤프 사용주기를 결정하는 부분 (0: dump 사용 안 함, 1: 매일 수행, 2: 이틀에 한 번 수행)
  6. 부팅 시 파일 시스템을 점검하는 fsck 명령의 순서를 정함

  <br>

  fstab 4번째 필드의 주요 옵션 (man mount에서 확인 가능)

  - defaults: rw, suid, dev, exec, auto, nouser, async가 적용됨
  - auto: 시스템 부팅 시 미디어가 존재하면 자동 마운트, -a 옵션을 이용한 마운트 및 활성화 등을 가능하게 함
  - noauto: 시스템 부팅 시 자동으로 마운트가 되지 않도록 함
  - user: 로컬 시스템에서 일반 사용자가 마운트할 수 있는 권한 부여
  - owner: 장치 소유자가 마운트할 수 있는 권한 부여
  - nofail: 해당 장치 파일이 존재하지 않는 경우에도 에러 보고를 하지 않음
  - quota, uquota, usrquota: 사용자의 용량을 제한하는 Disk quota를 사용할 때 해당 영역에 설정
  - gquota, grpquota: Disk quota를 그룹별로 사용할 때 해당 영역에 설정
  - noquota: 해당 파티션에서 사용자들의 QUota를 설정하지 않음
  - nosuid: 해당 파티션에서 SUID나 SGID 설정을 허용하지 않음
  - nodev: 해당 파티션에서 문자나 특별한 장치를 허용하지 않음
  - noexec: 해당 파티션에서 실행 파일이 실행되지 않도록 설정
  - suid: 해당 파티션에서 SUID나 SGID의 사용 허가
  - ro: 읽기 전용
  - rw: 읽고 쓰기 모드
  - async: 파일을 비동기적으로 관리하도록 설정
  - act: Access Control LIsts를 사용

- /etc/mtab: 현재 시스템에 마운트되어 있는 파일 시스템 정보를 담고 있는 파일

<br>

### 파일 시스템 점검 및 관리

- fsck: ext 계열 리눅스 파일 시스템을 검사, 수리하는 명령

  ```bash
  fsck [option] 장치명
  
  ## 주요 옵션 ##
  # -a: 명령 수행에 대한 확인 질문 없이 무조건 수행
  # -r: 명령 수행에 대한 확인 질문을 함, 여러 개의 fsck가 병렬로 작동 중일 경우 유용
  # -A: /etc/fstab에 정의되어 있는 모든 파일 시스템 체크
  # -P: -A 옵션 사용 시 루트 파일 시스템을 다른 파일 시스템과 병렬로 함께 체크
  # -R: -A 옵션 사용 시 루트 파일 시스템은 체크하지 않음
  # -N: 실행을 하지 않고 어떤 것이 실행되는지만 보여줌
  # -T: 검사를 시작할 때 제목을 보여 주지 않음
  # -s: fsck 동작을 시리얼화함, 대화형 모드에서 여러 파일 시스템 점검 시 유용
  # -V: 실행되는 각 파일 시스템용 명령을 포함해 자세한 출력 수행
  # -v: 버전 정보 보여줌
  # -t fs_type: 점검할 파일 시스템의 유형 지정 (파일 시스템 앞에 no를 붙이면 지정한 파일 시스템을 제외한 나머지를 검사, -A 옵션이 설정되어 있는 경우에는 /etc/fstab에서 파일 시스템 유형이 맞는 것만 검사)
  ```

- e2fsck: ext2, ext3, ext4를 검사하고 수리하는 명령 (fsck 명령 실행 시 실제 사용되는 명령어)

  ```bash
  e2fsck [option] 장치명
  
  ## 주요 옵션 ##
  # -n: 특정 상황에 대한 물음에 no로 인식하여 처리
  # -y: 특정 상황에 대한 물음에 yes로 인식하여 처리
  # -c: 배드 블록 체크
  # -f: 깨끗한 파일 시스템까지 강제로 체크
  ```

- xfs_repair: XFS 파일 시스템을 점검 및 복구할 때 사용하는 명령

  ```bash
  xfs_repair [option] 장치명
  
  ## 주요 옵션 ##
  # -n: 파일 시스템을 점검만 하고 복구하지 않음
  # -L: 관련 장치와 로그를 비움
  # -v: 점검 및 복구와 관련된 시간 정보를 추가로 출력
  # -V: 버전 정보 출력
  ```

- df: 현재 마운트된 디스크의 크기, 사용량, 남아 있는 용량 등에 대한 정보 출력

  ```bash
  df [option]
  
  ## 주요 옵션 ##
  # -h: 용량의 단위 표시를 해 줌
  # -k: 킬로바이트 단위로 보여줌
  # -m: 메가바이트 단위로 보여줌
  # -T: 각 파티션에 대한 파일 시스템의 유형을 보여 줌
  # -i: 아이노드의 사용량을 보여 줌
  ```

- du: 파일이나 디렉터리들이 디스크에서 차지하고 있는 크기 출력

  ```bash
  du [option] [FILE(s)]
  
  ## 주요 옵션 ##
  # -h: 용량의 단위 표시를 해 줌
  # -b: 바이트 단위로 보여줌
  # -k: 킬로바이트 단위로 보여줌
  # -m: 메가바이트 단위로 보여줌
  # -a: 디렉터리에 존재하는 모든 파일에 대해 각각의 크기를 보여줌
  # -s: 파일들의 전체 크기를 합한 값만 보여줌
  ```

- dd: 디스크를 이미지 형태로 백업하거나 파일의 포맷을 바꾸는 명령

  텍스트 파일의 대소문자 변환, 부팅 디스크 만들기, 스왑 파일 생성, 디스크 초기화 시 사용

  ```bash
  dd if=입력파일 [conv=conversion type] of=출력파일 [bs=] [count=] [skip=]
  
  ## 주요 항목 ## 
  # if=: 입력 파일 지정 (장치명이나 이미지 파일도 지정 가능)
  # of=: 출력 파일 지정 (장치명이나 이미지 파일도 지정 가능)
  # conv=: 변환하는 데이터 유형 지정 (lcase, ucase 등)
  # bs=: 출력되는 블록 사이즈 지정
  # count=: 변환되는 블록의 수 지정
  # skip=: 입력 파일의 시작되는 블록 번호 지정
  ```

- partprobe: 변경된 파티션 정보 반영 시 사용하는 명령, 해당 명령 사용 시 재부팅하지 않아도 반영됨

  반영 여부는 /proc/partitions에서 확인

  ```bash
  partprobe [options]
  
  ## 주요 옵션 ##
  # -d: 실제 적용되지 않고 실행 가능 여부만 점검
  # -s: 파티션 관련 정보를 간단히 출력
  # -h: 명령어 사용법 관련 정보를 출력
  # -v: 명령어의 버전 정보 출력
  ```

- stat: 파일 또는 파일 시스템 관련 정보 출력

  ```bash
  stat [option] 파일명
  
  ## 주요 옵션 ##
  # -f: 파일 대신 파일이 속한 파일 시스템 관련 정보 출력
  # -L: 심볼릭 링크 파일인 경우 원본 파일의 정보 출력
  # --printf=형식: 출력 형식 지정 가능
  ```

<br>

### 스왑(Swap) 생성

스왑: 하드 디스크의 일부를 메모리처럼 사용하게 해 주는 기술로 리눅스 설치 시 설정, 스왑 영역이 부족하 경우 리눅스 설치 후에도 디스크의 남은 공간이나 파티션을 이용해 추가 설정 가능

<br>

관련 명령어

- mkswap: 스왑 파티션이나 스왑 파일을 생성

  ```bash
  mkswap [option] 스왑_파일 [size]
  mkswap [option] 스왑_파티션
  
  ## 주요 옵션 ##
  # -c: 스왑 파티션 생성 전 배드 블록을 검사해주는 옵션
  ```

- swapon: 스왑 파티션이나 스왑 파일을 활성화시키는 명령, 스왑의 상태 확인 가능

  ```bash
  swapon [option] 스왑_파일
  swapon [option] 스왑_파티션
  
  ## 주요 옵션 ##
  # -a: /etc/fstab 파일에 등록된 스왑 영역을 전부 활성화시킴 (noauto 옵션이 설정된 경우 제외)
  # -s: 스왑 영역의 상태를 출력
  ```

- swapoff: 활성화된 스왑 파티션이나 스왑 파일을 중지시킴

  ```bash
  swapoff [option] 스왑_파일
  swapoff [option] 스왑_파티션
  
  ## 주요 옵션 ##
  # -a: 모든 스왑 영역을 중지시킴
  ```

- free: 현재 사용 중인 메모리 상태를 출력, 기본적인 정보는 /proc/meminfo 파일에서 가져옴

  ```bash
  free [option]
  
  ## 주요 옵션 ##
  # -m: 메모리의 상태를 MB 단위로 출력
  # -k: 메모리의 상태를 KB 단위로 출력
  # -h: 사람이 보기 편하도록 단위를 붙여서 출력
  ```

  free 명령을 사용하여 실제 유휴 메모리를 계산하려면 free 항목의 값과 buff/cache 항목의 값을 더해야 함

<br>

스왑 영역 만들기

1. 스왑 파일 생성 및 활성화
2. 스왑 파티션 생성 및 활성화

<br>

### Disk Quota

Disk Quota: 디스크의 사용량과 생성 가능한 파일의 개수를 제한하는 것

제한값 설정 관련 항목

- 소프트: 사용자에게 공지되는 제한 용량
- 하드: 실제 사용자가 최대로 사용할 수 있는 값 (보통 소프트보다 높음)

<br>

관련 명령어

- xfs_quota: XFS 파일 시스템의 쿼터 관리

  ```bash
  xfs_quota [option]
  
  ## 주요 옵션 ##
  # -x: 전문가 모드를 활성화시키는 옵션으로 관리자 명령 실행 시 기본으로 사용해야 하는 옵션
  # -c: 쿼터 관련 명령을 지정할 때 사용
  ```

- edquota: 사용자나 그룹에 쿼터를 설정할 때 사용하는 명령 (기본 단위:KB)

  ```bash
  edquota [option]
  
  ## 주요 옵션 ##
  # -u: 사용자에 대한 쿼터 설정 시 사용
  # -g: 그룹에 대한 쿼터 설정 시 사용
  # -t: Soft limit를 초과한 후부터 적용되는 시간 제한을 설정
  # -p: 특정 사용자의 쿼터를 다른 사용자에게 동일한 설정으로 적용 시 사용
  # -h: 명령어의 사용법 및 주요 옵션 정보 간략히 출력
  ```

- repquota: 파일 시스템에 설정된 쿼터 정보 출력

  ```bash
  repquota [option] 디렉터리명
  
  ## 주요 옵션 ##
  # -a: 쿼터가 설정되어 있는 모든 파티션의 정보 출력, 해당 옵션 사용 시 디렉터리 명 지정할 필요 없음
  # -u: 사용자 쿼터 정보 출력
  # -g: 그룹 쿼터 정보 출력
  ```

- quota: 사용자나 그룹 단위로 쿼터 설정 정보 출력

  ```bash
  quota
  
  ## 주요 옵션 ##
  # -u: 사용자 쿼터 정보를 출력
  # -g: 그룹 쿼터 정보 출력
  # -h: 명령어의 사용법 및 주요 옵션 정보를 간략히 출력
  ```

- setquota: 쿼터를 설정하는 명령으로 vi 편집기를 이용하지 않고 직접 명령행에서 설정 가능

  ```bash
  setquota [option] 사용자명 block_soft block_hard inode_soft inode_hard 파일 시스템
  setquota -t block_grace inode_grace 파일 시스템
  
  ## 주요 옵션 ##
  # -u: 사용자 쿼터 설정 시 사용 (default)
  # -g: 그룹 쿼터 설정 시 사용
  # -t: 유예 기간 설정 시 사용 (단위: 초)
  ```

<br>

사용자/그룹 쿼터 설정하기

1. /etc/fstab 설정
2. /home 영역 다시 마운팅
3. 적용 확인
4. 사용자/그룹에 대한 쿼터 설정
5. 쿼터 설정 확인

<br>

## 1.2.3 파일 시스템 관련 명령어

### 디렉터리 관련 명령어

- pwd: 현재 위치한 작업 디렉터리의 경로 출력

  ```bash
  pwd
  ```

- cd: 디렉터리 이동 (디렉터리 명을 입력하지 않는 경우 홈 디렉터리로 이동)

  ```bash
  cd [directory_name]
  ```

- mkdir: 디렉터리 생성

  ```bash
  mkdir [option] directory_name(s)
  
  ## 주요 옵션 ##
  # -p: 경로로 지정된 서브 디렉터리가 존재하지 않은 경우 함께 생성
  # -m: 디렉터리 생성과 동시에 퍼미션 설정
  # -v: 생성된 디렉터리를 메시지로 출력
  ```

- rmdir: 디렉터리 삭제 명령

  단, 삭제하려는 디렉터리 안이 비어 있지 않은 경우 삭제 불가능

  ```bash
  rmdir [option] directory_name(s)
  
  ## 주요 옵션 ##
  # -p: 디렉터리 삭제 후 부모 디렉터리도 빈 디렉터리가 되면 같이 삭제
  ```

- tree: 특정 디렉터리의 목록 정보를 트리 구조 형태로 출력

  기본적으로 설치되지 않기 때문에 사용하려면 `yum install tree`를 실행해 설치해야 함

  ```bash
  tree [option] [디렉터리명]
  
  ## 주요 옵션 ##
  # -l: 심볼릭 링크가 있는 경우 실제 디렉터리에 대한 정보 함께 출력
  # -a: 숨겨진 파일이나 디렉터리 정보도 함께 출력
  # -d: 디렉터리 정보만 출력
  # -f: 파일인 경우 지정한 디렉터리를 기준으로 전체 경로 형식으로 출력
  # -p: 허가권 정보도 함께 출력
  # -s: 파일의 크기 정보도 함께 출력
  # -h: 파일의 크기 정보를 사람이 읽기 쉬운 형태의 단위를 붙여서 출력
  ```

<br>

### 파일 관련 명령어

- ls: 디렉터리 안의 내용을 출력

  ```bash
  ls [option] [파일 또는 디렉터리명]
  
  ## 주요 옵션 ##
  # -a: 숨겨진 파일이나 디렉터리 출력
  # -A: .(현재 디렉터리) 및 ..(부모 디렉터리) 기호를 제외하고 '.'으로 시작하는 숨겨진 파일이나 디렉터리 출력
  # -F: 파일의 형태에 따라 관련 정보 출력
  # -l: 파일이나 디렉터리 정보를 한 줄씩 길게 보여 줌 (Permission, 링크 수(파일) 또는 이동 가능한 디렉터리 개수(디렉터리), 소유자, 그룹, 파일 크기, 최종 수정 시간, 파일 또는 디렉터리명)
  # -d: 대상이 디렉터리인 경우 디렉터리 안의 내용 대신 해당 디렉터리에 대한 정보 출력
  # -t: 출력되는 순서를 최근 수정된 파일 순서로 출력
  # -u: 파일 및 디렉터리의 최종 접근 시간 순서로 출력
  # -i: i-node 번호를 파일 또는 디렉터리 명 앞에 출력
  # -r: 알파벳 역순 출력
  # -R: 존재하는 하위 디렉터리별로 관련 내용을 재귀적으로 전부 출력
  # -S: 파일의 크기가 큰 것부터 출력
  # --color: 파일의 종류에 따라 색을 보여 줌
  # -1: 한 줄에 한 파일씩 출력
  # -h: 보기 쉽게 단위 표시
  # -Z: SELinux 관련된 보안 context 출력
  ```

- cp: 파일이나 디렉터리 복사

  ```bash
  cp [option] source(s) destination
  
  ## 주요 옵션 ##
  # -r, -R: 복사하려는 대상이 디렉터리인 경우 하위 디렉터리까지 복사
  # -i: 복사를 통해 생성한 파일이 존재하는 경우 덮어쓸 것인지 물어봄
  # -f: 같은 이름의 파일이 존재하는 경우 강제로 덮어씀
  # -b: 덮어쓸 때 백업본을 만듦
  # -s: 복사하는 대신 심볼릭 링크를 만듦
  # -p: 소유권, 그룹, 허가권 등 모든 정보를 복사함 (해당 옵션이 없는 경우 복사하는 사용자의 정보로 파일 복사)
  # -v: 파일 복사 전 각각 파일명 표시
  # -d: 심볼릭 파일인 경우 해당 심볼릭 정보와 함께 링크 파일 그대로 복사 (해당 옵션을 사용하지 않고 심볼릭 링크 파일을 복사하는 경우 원본 파일이 복사됨)
  # -a: -dpR 옵션과 같음 (파일의 정보 유지, 하위 디렉터리까지 복사)
  # -l: 복사 대신 하드 링크 파일 생성
  # -u: 복사 대상이 최신 파일이라면 복사되지 않음
  ```

- rm: 파일/디렉터리 삭제

  ```bash
  rm [option] file(s) 또는 directory
  
  ## 주요 옵션 ##
  # -i: 파일 삭제 시 질의 사용
  # -f: 강제 삭제
  # -r, -R: 하위 디렉터리를 포함헤 디렉터리 안의 모든 내용을 지움
  # --: 파일 이름이 -로 시작하는 파일 삭제
  ```

- mv: 파일/디렉터리의 이름 변경/이동

  ```bash
  mv [option] source(s) destination
  
  ## 주요 옵션 ##
  # -i: 이돌할 디렉터리에 동일한 파일명이 존재하는 경우 덮어쓸지 물어봄
  # -f: 강제 덮어쓰기
  # -b: 덮어쓸 때 백업본 생성
  # -v: 파일을 이동하는 내용 출력
  # -u: 이동할 디렉터리에 동일한 파일명이 있는 경우 검사해 해당 파일이 최신이면 이동하지 않음
  ```

- touch: 파일/디렉터리의 최종 접근 시간, 수정 시간 등 타임 스템프를 변경하거나 empty 파일 생성

  ```bash
  touch [option] 파일명
  
  ## 주요 옵션 ##
  # -a: 접근 시간 변경
  # -m: 수정 시간 변경
  # -t: 현재 시간 대신 [[CC]YY]MMDDhhmm[.ss] 형식으로 지정된 타임 스탬프로 변경
  # -r: 지정된 파일의 Access time 및 Modify time으로 특정 파일의 시간 변경
  ```

  타임 스탬프: 리눅스에서의 파일에 대한 시간 관련 정보 (이 중 Change Time은 절대 변경 불가)

- file: 파일의 종류 출력 (/use/share/magic 참조)

  ```bash
  file [option] 파일명
  
  ## 주요 옵션 ##
  # -b: 정보 출력 시 파일 이름을 출력하지 않음
  # -i: 특정 파일의 문자 집합 정보 출력
  ```

- locate: 시스템 전체에서 찾고자 하는 패턴과 맞는 파일/디렉터리를 경로와 함께 출력, 실제로 접근해 볼 수 있는 것들만 찾아 보여줌

  단, 데이터베이스화하여 찾는 명령이므로 파일이나 디렉터리 생성 후 데이터베이스 정보를 갱신하지 않으면 찾을 수 없음 (데이터베이스 갱신 명령: `updatedb`)

  ```bash
  locate [option] pattern
  
  ## 주요 옵션 ##
  # -c: 관련 정보의 경로 출력 대신 개수 출력
  # -i: 대소문자 구분하지 않음
  ```

  /var/lib/mlocate/mlocate.db 파일에서 데이터베이스 관리

- find: 현재 디렉터리부터 하위 디렉터리까지 여러 조건을 가지고 파일 및 디렉터리를 찾아 경로 출력

  root에서 접근 권한을 제한한 파일/디렉터리에 관해서는 찾지 못함

  ```bash
  find [path] options expression
  
  ## 주요 옵션 ##
  # -name: 주어진 이름의 파일/디렉터리 찾음
  # -user: 지정한 사용자의 파일/디렉터리 찾음
  # -group: 지정한 그룹의 파일/디렉터리 찾음
  # -uid: 지정한 UID 소유의 파일/디렉터리 찾음
  # -gid: 지정한 GID 소유의 파일/디렉터리 찾음
  # -perm: 지정한 허가권 값을 갖는 파일/디렉터리 찾음
  # -type: 지정한 파일 유형 찾음
  # -atime n: n일 이전에 접근한 파일을 찾음 (+n: n일 이전 액세스 파일 찾음, -n: n일 내에 액세스한 파일 찾음)
  # -ctime n: Change Time 기준으로 찾음
  # -mtime n: Modify Time 기준으로 찾음
  # -exec: 찾은 파일과 연계하여 명령을 내림, 결과값은 {} 기호로 표시하고 \\;로 끝나야 함
  # -ok: 확인 메시지를 출력하여 명령 실행 시 y, n을 입력받는 것을 제외하고 -exec와 같음
  # -print: 화면으로 출력받음 (생략 가능)
  # -fprint: 출력 결과를 파일에 저장 (')' 기호를 이용해도 됨)
  # -ls: ls -l과 같은 역할
  # -size n: n 블록 길이의 파일을 찾음
  # -inum n: node 번호가 n인 파일을 찾음
  # -iname: 대소문자 구분하지 않고 이름으로 찾음
  # maxdepth n: n만큼의 서브 디렉터리만 검사
  # -prune: 찾고자 하는 대상이 디렉터리인 경우 하위 디렉터리 검색을 하지 않음
  # -empty: 크기가 0인 파일이나 비어 있는 디렉터리를 찾음
  # -newer: 지정한 파일보다 뒤에 수정된 파일을 찾음
  # -cnewer: 지정한 파일보다 뒤에 변화된 파일을 찾음
  # 2>/dev/null: 접근 권한이 없는 파일/디렉터리 접근 시 나오는 Permission Denied 관련 리스트를 화면에 출력하지 않음
  ```

<br>

### 텍스트 파일 관련 명령어

- cat: 표준 입력으로 받는 값을 표준 출력으로 이어주는 명령

  ```bash
  cat [option] [filename(s)]
  
  ## 주요 옵션 ##
  # -b: 텍스트 파일 출력 시 행 번호를 붙여 줌 (공백만 있는 줄 제외)
  # -n: 텍스트 파일 출력 시 행 번호를 붙여 줌 (공백만 있는 줄 포함)
  # -E: 각 라인의 맨 끝에 개행 문자($)를 붙여 출력함
  # -T: 탭 문자를 ^| 표시하여 출력함
  # -v: 인쇄가 불가능한 문자를 식별할 수 있도록 출력함
  # -A: -vET 옵션을 통합한 옵션으로 일반적으로 출력되지 않은 모든 문자 출력
  # -s: 인접한 여러 공백 줄을 하나의 공백 줄로 출력
  ```

- head: 텍스트 파일의 첫 부분을 보여주는 명령으로 옵션 없이 사용하면 기본 10줄 출력

  ```bash
  head [option] filename(s)
  
  ## 주요 옵션 ##
  # -n 행수: 파일의 앞에서부터 지정된 수만큼 출력
  # -c n: n바이트까지 출력 (n 뒤에 k나 m을 쓸 경우 KB나 MB를 나타냄)
  # -q: 여러 개의 파일이 처리될 때 파일 이름을 출력하지 않음
  ```

- tail: 텍스트 파일의 끝 부분을 보여 주는 명령으로 옵션 없이 사용하묜 기본 10줄 출력

  ```bash
  tail [option] filename(s)
  
  ## 주요 옵션 ##
  # -n 행수: 파일의 뒤에서부터 지정된 수만큼 출력
  # -c n: 마지막 n바이트만 출력 (n 뒤에 k나 m을 쓸 경우 KB나 MB를 나타냄)
  # -f: 특정 파일 끝부분에 새로운 행이 추가되는 경우 실시간으로 출력
  # -q: 여러 개의 파일이 처리될 때 파일 이름을 출력하지 않음
  ```

- more: 텍스트 파일의 내용이 긴 경우 화면 단위로 출력

  ```bash
  more [option] filename
  
  ## 주요 옵션 ##
  # -num: 한 페이지를 num의 줄 수로 지정
  ```

- less: more 명령과 유사하나, more 명령은 실행 결과를 화면에 직접 출력하는 형식이고, less 명령은 버퍼 메모리를 사용해서 출력하는 방식

  man에서 호출되는 명령이 less

  ```bash
  less [option] filename
  
  ## 주요 옵션 ##
  # -?: less 실행 시 사용하는 명령들에 대한 도움말을 화면에 출력
  # -c: 화면에 출력하기 전 화면을 정리하여 맨 처음 위치되도록 함
  # -s: 인접한 여러 공백 줄을 하나의 줄로 처리하여 보여 줌
  # -e: less 실행 후 맨 끝 줄에 도달한 뒤 Enter나 Space 키를 누르면 자동으로 명령을 끝남
  # -N: 줄 번호를 보여 줌
  # +행번호: 지정한 행 번호부터 1page씩 보여줌
  ```

- grep: 텍스트 파일에서 특정 패턴을 가진 줄을 찾아 출력

  ```bash
  grep [option] pattern file(s)
  
  ## 주요 옵션 ##
  # -b: 일치하는 패턴이 있는 줄의 시작점 출력
  # -c: 일치하는 패턴이 있는 줄의 개수 출력
  # -h: 여러 개의 파일 검색 시 출력하는 파일의 이름이 붙는 것 방지
  # -i: 검색 시 대소문자 구분하지 않음
  # -n: 일치하는 패턴이 있는 줄의 번호와 내용 같이 출력
  # -v: 일치하는 패턴이 없는 줄 출력
  # -w: 패턴과 한 단어로 일치해야 출력
  # -x: 패턴과 한 줄로 일치해야 출력
  # -l: 주어진 패턴과 일치하는 패턴이 있는 파일 이름 출력
  # -r: 하위 디렉터리까지 찾음
  # -o: 지정한 패턴과 매칭되는 것만 출력
  # -E: |과 연계하여 여러 개의 패턴을 찾음 (=egrep)
  # -F: 지정한 특수문자 등을 기호 그대로 인식하여 출력 (=fgrep)
  # --color=auto: 검색하는 패턴과 매칭되는 문자열을 색깔로 표시하여 강조
  ```

  <br>

  정규표현식

  | 문자        | 설명                                                  |
  | ----------- | ----------------------------------------------------- |
  | .           | 한 문자가 무조건 존재                                 |
  | .*          | all                                                   |
  | a*          | 아무것도 없거나 a라는 문자열 하나이거나 반복된 문자열 |
  | [abc]       | [] 안의 문자 리스트 중 하나                           |
  | [0-9]       | 0~9 중 숫자 하나                                      |
  | [^1-3]      | 1, 2, 3을 제외한 모든 문자                            |
  | ‘^pattern’  | 주어진 패턴으로 줄이 시작하는 경우에만 검사           |
  | ‘pattern$’  | 주어진 패턴으로 줄이 끝나는 경우에만 검사             |
  | ‘\<pattern’ | 주어진 패턴으로 단어가 시작하는 경우에만 검사         |
  | ‘pattern\>’ | 주어진 패턴으로 단어가 시작하는 경우에만 검사         |

- wc: 텍스트 파일의 행 수, 단어 수, 문자 수 출력

  ```bash
  wc [option] file # 개행 문자까지 세어서 출력함
  
  ## 주요 옵션 ##
  # -l: 행 수만 출력
  # -w: 단어 수만 출력
  # -c: 문자 수만 출력
  # -L: 가장 긴 라인의 길이 출력
  ```

- sort: 텍스트 파일의 내용을 행 단위로 정렬 (기준: ASCII 코드 순)

  ```bash
  sort [option] file
  
  ## 주요 옵션 ##
  # -b: 선행하는 공백 문자 무시
  # -d: 공백, 알파벳, 숫자만으로 정렬
  # -f: 대소문자 무시
  # -r: 정렬 순서를 내림차순으로
  # -o: 정렬한 결과를 파일명으로 저장
  # -c: 파일이 정렬되었는지 검사, 정렬되었으면 아무 출력 없음, 미정렬 시 메시지 출력
  # -n: 숫자를 문자가 아니라 숫자값으로 취급해서 크기대로 정렬
  # -u: 중복되는 줄은 한 줄만 출력
  # -M: 월 표시 문자로 정렬 시 사용
  # -t: 필드 구분자를 지정 시 사용
  # -k n[,m]: 정렬할 위치를 지정하는 옵션으로 n번째 필드를 기준으로 정렬 (m이 있는 경우 n부터 m까지)
  ```

- cut: 데이터의 열 추출 시 사용

  ```bash
  cut option file
  
  ## 주요 옵션 ##
  # -c: 문자 수를 기준으로 추출
  # -f: 파일의 필드를 기준으로 추출
  # -d: 필드 구분자를 지정 (default: TAB)
  ```

- split: 하나의 파일을 여러 개의 파일로 분리하는 명령 (default: 1000줄 단위)

  ```bash
  split [option] file [file_name]
  
  ## 주요 옵션 ##
  # -b 값: 파일을 주어진 값의 바이트 크기로 분리
  # -l: 파일을 주어진 값을 라인 크기로 분리 (-값 형태로 지정해도 됨)
  
  ## 분할 파일은 cat으로 복원 가능
  cat data* > data
  ```

- tr: 텍스트 파일 안에 있는 임의의 문자(열)를 원하는 문자로 바꾸거나 제거할 때 사용

  원본 파일 내용이 바뀌지 않는 스트리밍 명령어

  명령행에서 사용하는 경우 반드시 <를 이용하여 입력을 지정해야 함

  ```bash
  tr [option] 문자1 문자2 < 파일명
  
  ## 주요 옵션 ##
  # -d: 주어진 문자 삭제
  # -s: 문자가 중복된 경우에 하나만 남기고 모두 삭제
  ```

- sed: 스트림 편집기로 셸 스크립트나 다른 명령의 출력을 여과하는 파이프라인을 사용

  파일의 내용을 변경 없이 화면상 출력만 필터링

  ed 명령과는 다르게 처리 단위가 라인이어거 입력 라인을 하나씩 읽고 수정하고 출력하기 때문에 버퍼를 사용하지 않음 → 큰 파일 처리 시 주로 사용

  ```bash
  sed [option] 'command' 텍스트파일명
  
  ## 주요 옵션 ##
  # -n: 특정한 행 지정 시 사용
  # -f 파일명: 특정한 스크립트가 들어있는 파일로부터 읽어들여서 처리
  # -i 표현식: 치환 구문과 같이 사용하는데, 치환된 내용을 파일에 반영
  
  ## command ##
  # 'n'a\\ text: n은 정수값으로 지정한 행 밑에 문자열을 추가하여 출력, n을 지정하지 않으면 매 행마다 문자열을 덧붙여 출력
  # 'n'd 지정한 행을 삭제하여 출력, 범위 지정 가능
  # 'n'i\\ text: 지정한 행 앞에 문자열을 행으로 삽입해 출력
  # p: 선택한 행을 한 번 더 출력, '/문자열/p'의 경우 선택한 문자열이 있는 행을 한 번 더 출력하고 p command만 사용하는 경우 모든 행을 두 번씩 출력
  # q: 명시된 행에 도달할 때 종료
  # r 파일명: 파일을 읽어 출력
  # s/string1/string2/: 각 행의 첫 번째 string1만 string2로 바꿈
  # s/string1/string2/g: 모든 행에 존재하는 string1을 string2로 바꿔 출력 (s\\string1\\string2\\g도 가능)
  ```

- awk: 패턴 검색과 조작 시 주로 사용

  grep 명령으로 넘어온 데이터들의 값을 처리하거나 sed와 함께 정규화된 양식을 처리하는 경우 많이 사용됨

  ```bash
  awk [options] 'pattern{action}' filename
  
  ## 주요 옵션 ##
  # -F 필드구분자: 필드 구분자 설정 시 사용 (default: 공백)
  # -f 파일명: 특정 스크립트 파일 지정 시 사용
  
  ## 주요 패턴 ##
  # BEGIN: 입력 파일을 읽어 들이기 전 제시되는 문자 실행 시 지정
  # END: awk가 모든 입력을 처리한 후 옆에 제시되는 문자를 실행시키도록 할 때 지정
  # /문자열/: 문자열과 일치하는 라인을 찾아 action 실행
  
  ## 주요 액션 ## 
  # print: 제시된 표현식을 표준 출력
  ```

<br>

# 1.3 프로세스 관리

## 1.3.1 프로세스의 제어

### 프로세스 우선순위

`ps -l` 명령어로 프로세스 우선 순위 확인 가능

- PRI: 커널이 사용하는 우선순위 항목으로 0~139의 값, 값이 작을수록 우선순위가 높음

  인위적 조작이 불가능하며 시스템 상황에 따라 적절히 부여

  0~99: 시스템에 예약된 우선순위 값

  100~139: 사용자 공간 프로세스 할당 값

- NI: root나 사용자가 조작하는 우선순위 값으로 -20부터 19까지 설정 가능, 값이 작을수록 우선순위가 높음

<br>

### 프로세스와 /proc 디렉터리

**/proc의 개요**

가상 파일 시스템으로 시스템에 동작 중인 프로세스의 상태 정보와 기타 시스템 및 하드웨어 정보 확인 가능

프로세스와 커널의 내부적인 정보 제공을 위해 만들어진 영역

새로운 프로세스가 생성되면 /proc 디렉터리 안에 PID 와 동일한 서브 디렉터리가 생성되고 그 안에 해당 프로세스 관련 정보가 저장됨

<br>

/proc/PID의 구조

| 구성요소 | 설명                                              |
| -------- | ------------------------------------------------- |
| cmdline  | 명령행 옵션 정보                                  |
| cwd      | 작업 디렉터리                                     |
| environ  | 프로세스 환경에 대한 정보                         |
| exe      | 해당 프로세스를 실행시킨 명령어                   |
| fd       | 파일 지정자에 대한 정보                           |
| maps     | 실행 명령과 라이브러리 파일의 메모리 맵 정보      |
| mounts   | 시스템 마운트 정보                                |
| root     | 해당 프로세스의 루트 디렉터리                     |
| stat     | 해당 프로세스의 상태 (보통 ps 명령에 의해 사용됨) |
| statm    | 프로세스의 메모리 상태에 대한 정보                |
| status   | 프로세스 상태 정보                                |

<br>

/proc 디렉터리의 주요 정보 파일 및 디렉터리

| 파일 또는 디렉터리 | 설명                                                         |
| ------------------ | ------------------------------------------------------------ |
| acpi               | 전원 관련 정보                                               |
| bus                | pci와 같은 bus 정보                                          |
| cmdline            | 부팅 시 실행되는 커널 관련 옵션 정보                         |
| cpuinfo            | CPU에 관한 정보                                              |
| devices            | 현재 커널에 설정된 디바이스 드라이버의 리스트 정보           |
| dma                | 시스템에서 사용 중인 DMA 정보                                |
| filesystems        | 커널에 설정된 파일 시스템의 리스트 정보                      |
| interupts          | 시스템에서 사용 중인 인터럽트 정보                           |
| iomem              | 메모리 번지별로 할당된 리스트 정보                           |
| ioports            | 시스템에서 사용 중인 I/O 주소                                |
| kallsyms           | 커널에 의해 공개된 심볼 정보                                 |
| kcore              | 시스템에 장착된 물리적 메모리의 이미지로 실제 하드 디스크의 용량을 차지하지는 않음 |
| kmsg               | 커널 동작 중 중요한 이벤트가 생시면 출력되는 메시지 정보     |
| loadavg            | 최근 1분, 5분, 15분 동안의 평균 부하율                       |
| locks              | 현재 lock 파일에 대한 정보                                   |
| mdstat             | RAID 사용 시 관련 정보 기록                                  |
| meminfo            | 물리적 메모리 및 스왑 메모리 정보                            |
| misc               | 기타  장치에 대한 정보                                       |
| mounts             | 시스템에 마운트된 정보                                       |
| net                | Network 관련 정보                                            |
| partitions         | 현재 활성화된 파티션 정보                                    |
| scsi               | SCSI 관련 정보                                               |
| self               | 프로세스에 대한 정보                                         |
| stat               | 커널과 시스템 상태 정보                                      |
| swaps              | 스왑 파티션 관련 정보                                        |
| sys                | 커널과 관련된 정보, sysctl 명령으로 제어                     |
| sysvipc            | SysV IPC 자원 정보                                           |
| uptime             | 시스템 가동 시간에 대한 정보                                 |
| version            | 커널 버전 정보                                               |

<br>

### 프로세스 스케줄링

- at

  지정한 시간에 원하는 명령이나 작업이 실행되도록 하며 한 번 실행되는 경우에 주로 사용

  atd 데몬에 의해 실행되고 지정한 작업은 큐에 저장되며 저장된 작업들은 /var/spool/at 디렉터리 아래 파일로 저장됨

  실행 시 at> 프롬프트가 나타나고 원하는 작업 순차적으로 입력 후 ctrl + d 입력

  /etc/at.allow, /etc/at.deny 파일로 at 사용자 제한 가능

  ```bash
  at [option] 시간 # 시간 지정은 HHMM, HH:MM 형태로 가능하고 am, pm으로 구분 가능
  
  ## 주요 옵션 ##
  # -q 큐이름: 작업의 대기 큐 지정 (default: a, 사용 가능한 큐: a-z, A-Z)
  # -c 작업: 작업 정보 출력
  # -d: 예약한 작업 삭제 (=atrm)
  # -l: 큐에 있는 작업 출력, root인 경우 모든 작업의 목록 출력(=atq)
  # -m: 실행한 결과를 메일로 통보
  # -f: 지정한 파일로부터 작업을 읽어옴
  ```

  관련 명령어

  - atq: 큐에 저장된 작업을 보여 주는 명령

    작업 번호, 작업이 실행되는 시간, 작업이 저장되어 있는 큐, 사용자 순으로 출력됨

    ```bash
    atq
    ```

  - atrm: 예약된 작업을 취소 시 사용

    ```bash
    atrm 작업번호
    ```

- cron

  주기적으로 프로세스를 실행하는 경우 사용

  시스템 운영에 필요한 작업은 root 권한으로 /etc/crontab에 등록하여 주기적 수행 가능

  사용자의 경우 crontab이라는 명령을 수행해 등록 가능

  /etc/cron.allow, /etc/cron.deny 파일로 cron 사용자 제한 가능

  cron 필드 구성 요소

  | 필드         | 설정 값 및 내용                                      |
  | ------------ | ---------------------------------------------------- |
  | minute       | 분을 나타내고 0~59로 설정                            |
  | hour         | 시를 나타내고 0~23으로 설정                          |
  | day or month | 날을 나타내고 1~31로 설정                            |
  | month        | 월을 나타내고 1~12로 설정                            |
  | day of week  | 요일을 나타내고 0~7로 설정, 영문으로 입력 가능 (sun) |
  | 0, 7: 일요일 |                                                      |
  | user-name    | 사용자 이름, 일반적으로 생략                         |
  | command      | 실행할 명령어                                        |

  각 필드는 ‘*’, ‘-’, ‘,’,’/’를 사용 가능

  - *: all
  - -: 연결된 설정값 지정
  - ,: 연결되지 않은 값 나열
  - /: 연결된 설정 값 범위 중 특정 주기로 나눌 때 사용

  관련 명령어

  - crontab

    작업 설정 시 /var/spool/cron/사용자아이디 파일로 저장됨

    ```bash
    crontab [option]
    crontab [option] 파일명
    
    ## 주요 옵션 ##
    # -l: crontab에 설정된 내용 출력
    # -e: crontab의 내용을 작성/수정
    # -r: 저장된 파일 삭제
    # -u: root 사용자가 특정 사용자의 crontab 파일을 다룰 때 사용
    # -i: 삭제 시 질의 입력받음
    ```

<br>

## 1.3.2 프로세스 관련 명령어

### ps

동작 중인 프로세스 상태 출력

System V 계열은 옵션 사용 시 -를 사용하고 BSD 계열은 -를 사용하지 않음, GNU에서의 옵션 표기는 --를 사용

```bash
ps [option]

## 주요 옵션 ## 
# a: 터미널과 관련된 프로세스를 출력하는 옵션으로 보통 x 옵션과 연계하여 모든 프로세스 출력 시 사용 (BSD)
# u: 프로세스 소유자를 기준으로 출력
# x: 터미널에 종속되지 않은 프로세스 출력
# l: 프로세스의 정보를 길게 보여줌
# e: 해당 프로세스에 관련된 환경 변수 정보를 함께 출력
# f: 프로세스 간 상속 관계를 트리 구조로 보여줌
# p: 특정 PID를 지정 시 사용 (BSD)
# -A: 모든 프로세스 출력 (= -e, System V)
# -e: 모든 프로세스 출력
# -a: 세션 리더(로그인 셸)를 제외하고 터미널에 종속되지 않은 모든 프로세스 출력
# -f: 유닉스 스타일로 출력
# -C 프로세스명: 지정한 프로세스만 보여줌
# -o 값: 출력 포맷을 지정
# -p: 특정 PID를 지정할 때 사용 (System V)
# -u: 특정 사용자의 프로세스 정보 확인 시 사용
```

<br>

### pstree

프로세스의 상태를 트리 구조로 출력

```bash
pstree [option]

## 주요 옵션 ##
# -a: 각 프로세스의 명령행 인자까지 보여줌
# -h: 현재 프로세스와 그것의 조상 프로세스를 하이라이트로 강조해서 보여줌
# -n: 프로세스 이름 대신 PID 값으로 정렬
# -p: PID 값을 같이 보여줌
```

<br>

### top

동작 중인 프로세스의 상태를 실시간으로 화면에 출력

```bash
top [option]

## 주요 옵션 ##
# -d 갱신시간: 초단위로 갱신 시간 설정
# -p: 특정 PID 값을 갖는 프로세스를 모니터링할 때 사용
# -b: 배치 모드로 실행 (보통 -n 옵션과 같이 실행)
# -n 값: top 명령의 실행 횟수 지정
```

<br>

### kill

프로세스에 특정한 시그널을 보내는 명령으로 옵션 없이 실행하면 프로세스에 종료 신호(15, TERM, SIGTERM)를 보냄

중지시킨 수 없는 프로세스를 종료시킬 때 주로 사용

```bash
kill [option] [signal] [PID 또는 %job_number]

## 주요 옵션 ##
# -l: 시그널의 종류 출력
# -s signal: 시그널의 이름 지정
```

<br>

### killall

같은 데몬의 여러 프로세스를 한 번에 종료시킬 때 사용

시그널을 지정하지 않으면 종료 시그널이 전송됨

```bash
killall [option] 프로세스명

## 주요 옵션 ##
# -l: 시그널의 종류 출력
# -w: 시그널을 받은 프로세스들이 종료될 때까지 기다림
# -v: 시그널이 전송된 결과 출력
# -s signal: 시그널의 이름 지정
# -u 사용자명: 특정 사용자의 프로세스 지정
```

<br>

### jobs

백그라운드로 실행 중인 프로세스나 현재 중지된 프로세스의 목록 출력

```bash
job [option]

## 주요 옵션 ##
# -l: 프로세스 번호를 추가로 출력
```

<br>

### fg

백그라운드 프로세스를 포어그라운드 프로세스로 전환

백그라운드로 수행 중인 작업이 여러 개인데 job_number를 지정하지 않는 경우 가장 최근에 수행한 작업 전환

```bash
fg [%job_number]
fg [job_number]
```

<br>

### bg

포그라운드 프로세스를 백그라운드 프로세스로 전환

전환 시 CTRL + z를 눌러 작업을 일시 중지 시킨 후 전환

```bash
bg
```

<br>

### nice

프로세스의 우선 순위를 변경하는 명령으로 NI 값을 설정할 떄 사용

일반 사용자는 NI 값 증가만 가능하고 root 사용자만 NI 값 감소 가능

```bash
nice [option] 프로세스명

## 주요 옵션 ##
# -n 값, -값, --adjustment=값: 프로세스에 설정된 NI 값을 지정된 값만큼 증감
```

<br>

### renice

실행 중인 프로세스의 우선 순위를 변경하는 명령으로 PID, 사용자 이름, 프로세스의 그룹ID를 이용

기존 NI 값과 관계없이 지정한 NI 값이 바로 설정됨

일반 사용자는 NI 값 증가만 가능하고 root 사용자만 NI 값 감소 가능

```bash
renice [option] NI 값 PID

## 주요 옵션 ##
# -n: NI 값을 지정 시 사용하는 옵션이나 일반적으로 생략함
# -p: PID 지정
# -u: 사용자 이름 지정
# -g: 프로세스 그룹 ID 지정
# -v: renice 명령어를 설치한 패키지의 버전 정보 출력
# -h: 명령어의 간단한 사용법 출력
```

<br>

### nohup

사용자가 로그아웃하거나 작업 중인 터미널 창이 닫혀도 실행 중인 프로세스를 백그라운드 프로세스로 작업할 수 있도록 하는 명령

nohup는 실행하는 명령을 백그라운드 프로세스로 생성하지 않으므로 사용자가 명령행 뒤에 ‘&’를 명시해야 함

백그라운드로 실행되는 명령행 앞에 붙이는 명령

```bash
nohup 명령
```

<br>

### pgrep

프로세스를 이름 기반으로 검색하는 명령으로 PID 값 출력

```bash
pgrep [option] [pattern]

## 주요 옵션 ##
# -u: 특정 사용자가 실행시킨 프로세스의 PID 출력
# -U: 특정 UID를 갖는 사용자가 실행시킨 프로세스의 PID 출력
# -g: 특정 그룹이 실행시킨 프로세스의 PID 출력
# -G: 특정 GID를 갖는 그룹이 실행시킨 프로세스의 PID 출력
# -t: 특정 터미널에 실행 중인 프로세스의 PID 출력
# -l: 프로세스명도 같이 출력
```

<br>

### pkill

프로세스명을 사용해 특정 프로세스에 시그널을 보내는 명령

기본 시그널은 15번 시그널인 TERM 시그널

```bash
pkill [option] [pattern]

## 주요 옵션 ##
# -u: 특정 사용자가 실행시킨 프로세스의 PID에 시그널을 보냄
# -U: 특정 UID를 갖는 사용자가 실행시킨 프로세스에 시그널을 보냄
# -g: 특정 그룹이 실행시킨 프로세스의 PID에 시그널을 보냄
# -G: 특정 GID를 갖는 그룹이 실행시킨 프로세스의 PID에 시그널을 보냄
# -t: 특정 터미널에 실행 중인 프로세스의 PID에 시그널을 보냄
# -l: 프로세스명도 같이 출력
```

<br>

# 1.4 소프트웨어 설치 및 관리

## 1.4.1 패키지를 통한 소프트웨어 설치

### 프로그램 설치의 개요

소스로 제공되는 프로그램은 여러 단계를 거쳐 설치 가능

1. 압축 풀기
2. configure
3. make
4. make install

해당 작업이 복잡해 배포판별로 패키지 관리 기법을 제공함

배포판별 패키지 관리 기법

| 배포판      | 기본 패키지 관리 기법 | 온라인 패키지 관리 기법 |
| ----------- | --------------------- | ----------------------- |
| 레드햇 계열 | RPM                   | YUM                     |
| 데비안 계열 | Dpkg                  | apt-get                 |
| 수세 계열   | YaST                  | zypper                  |

<br>

### RPM(Red Hat Package Manager)

.rpm 형태의 파일로 배포하고 rpm 명령을 사용하여 설치, 갱신, 제거, 검증, 질의 등의 관리 가능

rpm 파일의 형식

패키지이름-버전-릴리즈.리눅스버전.아키텍처.rpm

| 구성        | 설명                                   |
| ----------- | -------------------------------------- |
| 패키지이름  | 어떤 패키지인지 알려주는 패키지의 이름 |
| 버전        | 패키지의 버전                          |
| 릴리즈      | 한 버전의 패키지를 몇 번 빌드했는지    |
| 리눅스 버전 | 기준이 되는 리눅스 버전                |
| 아키텍처    | 패키지가 사용 가능한 시스템            |

<br>

rpm 사용법

```bash
rpm [option] [패키지_파일명] --
```

- 설치 및 갱신 모드

  주요 옵션

  | 옵션        | 설명                                                         |
  | ----------- | ------------------------------------------------------------ |
  | -i          | 새로운 패키지 설정 시 사용 (이전 버전의 같은 패키지가 있는 경우 설치되지 않음) |
  | -U          | 기존의 패키지를 새로운 패키지로 업그레이드할 경우 사용 (설치된 패키지가 없는 경우 새롭게 설치됨) |
  | -F          | 이전 버전이 설치되어 있는 경우에만 설치                      |
  | -v          | 메시지를 자세히 보여줌                                       |
  | -h          | 설치 상황을 # 기호로 표시                                    |
  | --force     | 기존 버전이 설치되어 있는 경우처럼 강제로 설치하는 경우 사용 |
  | --nodeps    | 의존성 관계를 무시하고 설치 (해당 옵션 미사용 시 의존성 관계에 있는 패키지가 존재하지 않으면 설치되지 않음) |
  | -vv         | 메시지를 아주 자세히 보여줌                                  |
  | --test      | 실제 파일에 기록하는 작업을 제외한 대부분을 테스트하는 경우 사용 |
  | --rebuilddb | rpm 데이터베이스 업데이트 시 사용                            |

- 제거 모드

  다른 패키지에 대한 의존성이 발생한 경우에는 제거되지 않음 의존성 관련 패키지를 제거하거나 --nodeps 옵션을 지정해 주어야 함

  주요 옵션

  | 옵션         | 설명                                                         |
  | ------------ | ------------------------------------------------------------ |
  | -e           | 설치된 패키지를 삭제                                         |
  | --nodeps     | 의존성을 갖는 패키지가 존재하는 경우에도 삭제                |
  | --test       | 실제로 제거하지 않고 테스트함                                |
  | --allmatches | 동일한 이름을 갖는 패키지가 중복 설치되어 있는 경우 모두 제거 |

- 질의 모드

  패키지 관련 정보를 알아냄

  주요 옵션

  | 옵션             | 설명                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | -q               | 질의 시 꼭 사용해야 하는 옵션, 패키지를 찾으면 이름과 버전만 표시 |
  | -i               | 설치된 패키지의 정보 출력                                    |
  | -l               | 패키지에서 설치한 모든 파일의 정보 출력                      |
  | -a               | 시스템에 설치된 모든 패키지 목록 출력                        |
  | -p 패키지_파일명 | rpm 패키지의 파일에 대한 정보를 보여 줌 (패키지 파일의 정확한 이름을 입력해야 함) |
  | -f 파일명        | 지정한 파일을 설치한 패키지 이름 출력                        |
  | -c               | 해당 패키지의 설정 파일이나 스크립트 파일 출력               |
  | -d               | 해당 패키지의 문서 파일 출력                                 |
  | -R               | 어떤 패키지에 의존하고 있는지 출력                           |
  | --changelog      | 특정 패키지의 바뀐 내역을 최근부터 연대 순으로 보여줌        |
  | --scripts        | 설치 및 제거 관련 스크립트를 보여줌                          |
  | --filesbypkg     | rpm 패키지가 많을 경우 목록으로 보이는 파일 앞에 패키지명을 붙임 |
  | --queryformat    | 질의의 결과를 원하는 형태로 출력하는 경우 사용               |

- 검증 모드

  rpm 데이터베이스에 저장되어 있는 패키지의 메타데이터 정보를 이용하여 변경된 정보를 찾아내는 모드

  검증 코드

  | 코드 | 설명                                     |
  | ---- | ---------------------------------------- |
  | S    | 파일 크기 변경                           |
  | M    | 파일 모드 변경                           |
  | 5    | 메시지 다이제스트 변경                   |
  | D    | 장치 파일의 메이저 및 마이너 번호 불일치 |
  | L    | 링크 파일 경로 불일치                    |
  | U    | 소유자 변경                              |
  | G    | 그룹 소유권 변경                         |
  | T    | 수정 시간 변경                           |
  | P    | 권한 변경                                |
  | .    | 테스트 통과                              |
  | ?    | 테스트를 수행하지 못했을 경우            |

  주요 옵션

  | 옵션 | 설명                         |
  | ---- | ---------------------------- |
  | -V   | 검증 시 사용하는 기본 옵션   |
  | -a   | 모든 패키지를 검사할 때 사용 |

- 리빌드 모드

  rpm 소스 파일인 .src.rpm 파일을 패키지 파일로 만드는 모드

  ```bash
  rpmbuild [option] 소스패키지
  
  ## 주요 옵션 ##
  # --rebuild: 소스 rpm 파일을 이용해서 rpm 패키지 생성 시 사용
  ```

<br>

### yum

yum(Yellowdog Updater, Modified): rpm 기반의 시스템에서 패키지를 손쉽게 설치해주고 자동으로 업데이트를 수행하는 명령행 기반 유틸리티

yum 관련 파일 및 디렉터리

- /etc/yum.conf: yum 환경 설정 파일
- /etc/yum.repos.d: 설치 및 업데이트를 위한 저장소 관련 파일
- /var/cache/yum/x86_64/7/base: 작업 관련 정보 저장 디렉터리
- /var/log/yum.log: 관련 작업의 로그 저장

<br>

yum 사용법

```bash
yum [option] [command] [패키지_파일명]

## 주요 옵션 ##
# -y: 모든 질의에 y라고 대답
# -v: 자세한 정보 출력

## command ##
# list [항목]: 전체 패키지에 대한 정보 출력
# info [패키지명]: 패키지에 대한 정보 출력
# check-update: 업데이트가 필요한 패키지 출력
# update [패키지명]: 패키지 업데이트
# install [패키지명]: 패키지 설치 (의존성 관련 패키지도 같이 설치)
# search [문자열]: 문자열이 포함된 패키지를 찾음
# remove/erase [패키지명]: 패키지 삭제
# group list: 패키지 그룹에 대한 정보 출력
# group info 패키지그룹명: 해당 패키지 그룹명과 관련된 패키지의 정보 출력
# group update 패키지그룹명: 지정한 그룹의 패키지 업데이트
# group install 패키지그룹명: 지정한 그룹의 패키지 설치
# group remove 패키지그룹명: 지정한 그룹의 패키지 제거
# whatprovices: 특정한 파일이나 기능과 관련된 패키지 정보 검색
# clean [값]: yum 관련해서 저장된 정보를 삭제할 때 사용
# history [sub-command]: yum 명령을 사용한 작업 이력 정보 출력
```

<br>

yum-utils 패키지의 yumdownloader 명령을 사용하면 rpm 패키지 다운로드 가능

```bash
yumdownloader --destdir=다운로드할폴더경로 패키지명
```

<br>

### 데비안 패키지 관리(Debian Package Management)

데비안 리눅스는 관련 프로그램을 .deb 형태의 파일로 배포하여 설치, 삭제 등의 관리를 함

데비안 패키지 관리 도구로는 dpkg를 사용하며, dselect, alien도 있음

deb 파일의 형식

패키지이름_버전-릴리즈-아키텍처.deb

| 구성       | 설명                                   |
| ---------- | -------------------------------------- |
| 패키지이름 | 어떤 패키지인지 알려주는 패키지의 이름 |
| 버전       | 패키지의 버전                          |
| 릴리즈     | 한 버전의 패키지를 몇 번 빌드했는지    |
| 아키텍처   | 패키지가 사용 가능한 시스템            |

<br>

dpkg 사용법

```bash
dpkg [option] [패키지명] [패키지_파일명]

## 주요 옵션 ##
# -i 패키지_파일명: 패키지 설치 시 사용
# -R 디렉터리명: -i와 같이 사용되어 지정한 디렉터리 안에 있는 패키지 설치 시 사용
# -l: 설치되어 있는 패키지 출력
# -I 패키지_파일명: 패키지 파일에 대한 정보 출력
# -c 패키지_파일명: 패키지 파일에 포함된 파일 정보 출력
# -L 패키지명: 패키지가 설치한 파일 목록 출력
# -r 패키지명: 패키지를 제거하는데 환경 설정 파일을 남겨둠
# -P 패키지명: 환경설정 파일까지 전부 제거
# -S 파일명: 해당 파일을 설치한 패키지 이름을 출력
# -C: 완전히 설치되지 않은 패키지에 대한 검사를 함
# --unpack 패키지_파일명: 환경 설정은 하지 않고 패키지를 풀기만 함
# --configure 패키지명: --unpack 옵션으로 풀린 패키지를 환경 설정 하는 경우 사용
# -a: 언팩된 패키지들에 대해 환경 설정을 함
# -s 패키지명: 패키지에 대한 상태 출력
```

<br>

### apt-get

데비안 리눅스 배포판에서 패키지 관리를 쉽게 하기 위해 제공되는 명령행 기반 유틸리티

/etc/apt/sources.list 파일에 패키지 관련 정보를 관리하여 의존성과 충돌성 해결

```bash
apt-get [option] [command] [패키지명]

## 주요 옵션 ##
# -y: 모든 질의에 y라고 대답
# --purge: remove 명령을 수행할 때 환경 설정까지 같이 제거

## command ##
# update: 패키지 목록 갱신 시 사용 (관련 정보는 /etc/apt/sources.list)
# upgrade: 모든 패키지를 최신 버전으로 갱신 (update 후 사용)
# install 패키지명: 패키지 설치 시 사용 (해당 명령 사용 시 .deb 파일이 /var/cache/apt/archive에 생성됨)
# remove 패키지명: 패키지 삭제
# clean: /var/cache/apt/archive에 생성된 파일 삭제
```

<br>

## 1.4.2 소스 코드 컴파일

### 소스 설치법의 개요

리눅스에서 소스 프로그램 설치 단계

1. 압축 풀기

2. 디렉터리 이동

3. configure

   소스 프로그램의 환경 설정을 하는 스크립트로 컴파일 등에 필요한 정보를 시스템에서 찾은 후 Makefile을 생성함

4. make

   Makefile을 읽어 소스 코드에서 실행 가능한 프로그램과 라이브러리를 자동으로 빌드

   configure에 의해 변경된 내용을 반영하고 타깃과 의존성 관련 작업을 한 후 최종 실행 파일 생성

5. make install

   컴파일된 실행 파일을 지정한 속성으로 지정된 디렉터리에 설치

<br>

### cmake

**cmake의 개요**

Make의 대체 프로그램으로 멀티 플랫폼을 지원하기 위한 목적으로 등장한 오픈소스 프로젝트

cmake는 make 과정을 수행하지 않고 지정한 운영체제에 맞는 make 파일의 생성을 목적으로 함

<br>

**cmake의 특징**

- 소프트웨어 빌드에 특화된 언어로 독자적인 설정 스크립트 이용
- 다양한 플랫폼 지원
- C, C++, Java, Fortran에 대해서는 자체적으로 의존 관계 분석 가능
- SWIG, Qt, FLTK 등을 지원
- Visual Studio .Net 및 Visual Studio 지원
- 이클립스용 빌드 파일 생성 가능
- 타임스탬프를 통해 파일 내용의 변화를 알 수 있음
- 평행 빌드를 지원
- 크로스 컴파일을 할 수 있음
- Datr, CTest, CPack 등을 포함

<br>

### 압축 관련 유틸리티

- tar

  여러 파일을 하나의 파일로 묶어 주는 명령으로 디렉터리 지정 시 해당 디렉터리의 모든 파일과 서브 디렉터리까지 함께 묶어짐

  파일의 속성, 하드링크, 심볼릭링크 등도 보존됨

  지원되는 압축 형식: compress(tar.Z), gzip(tar.gz), bzip2(tar.bz2), xz(tar.xz)

  ```bash
  tar [option] [파일명] # 옵션 사용 시 -를 사용하지 않아도 되지만 인자값이 있는 옵션을 여러개 지정하는 경우 -를 사용해야 함
  
  ## 주요 옵션 ##
  # -c: 지정한 파일이나 디렉터리를 하나로 묶어 새로운 tar 파일 생성
  # -x: 생성된 tar 파일을 풂
  # -v: 어떤 명령을 실행할 때 대상이 되는 파일을 보여 줌
  # -f 파일명: 작업 대상이 되는 tar 파일의 이름을 지정 (파일명 대신 -를 쓰면 표준 입출력이 됨)
  # -r: 기존의 tar 파일 뒤에 파일 추가
  # -t: tar 파일 안에 묶여 있는 파일의 목록 출력
  # -h: 심볼릭 링크가 가리키고 있는 원본 파일 저장
  # -C: 디렉터리 변경 시 사용
  # -p: 파일이 생성되었을 때 권한을 그대로 유지하게 해줌 (root 사용자에게는 기본 적용 옵션)
  # -Z: compress 관련 옵션으로 tar.Z에 사용
  # -z: gzip 관련 옵션으로 tar.gz에 사용
  # -j: bzip2 관련 옵션으로 tar.bz2에 사용
  # -J: xz 관련 옵션으로 tar.xz에 사용 (--xz)
  # --delete: 생성된 tar 파일에서 특정 파일 삭제
  ```

- compress, uncompress

  전통적으로 유닉스에서 사용했던 압축 프로그램이지만 리눅스에서는 압축률이 낮아 쓰이지 않음

  레드햇 계열 리눅스에서 ncompress 패키지 설치 시 사용 가능

  ```bash
  compress [option] 파일명 # 압축
  uncompress [option] 파일명 # 압축 해제
  
  ## 주요 옵션 ##
  # -c: 표준 출력으로 지정하는 옵션으로 보통 생략 (tar 등과 병행하여 사용 시 반드시 표기)
  # -v: 압축 관련 정보 출력
  ```

- gzip, gunzip

  GNU에서 만든 압축 프로그램

  ```bash
  gzip [option] 파일명 # 압축
  gunzip [option] 파일명 # 압축 해제
  
  ## 주요 옵션 ##
  # -d: 압축 해제 시 사용
  # -1: 파일의 압축 시간을 줄임 (압축은 빠르지만 압축률은 떨어짐)
  # -9: 파일을 최대로 압축함 (압축 시간이 늘어남)
  # -c: 결과를 표준 출력으로 보낼 때 사용 (tar와 병행해 작업 시 사용)
  # -l: 압축 파일에 대한 정보 출력 
  # -r: 대상이 디렉터리인 경우 하위 디렉터리까지 찾아 처리
  # -v: 진행 과정을 이름 및 퍼센트와 함께 자세히 보여줌
  ```

  zcat: gzip 패키지에 같이 들어있는 명령으로 압축되어 있는 텍스트 파일의 내용 확인 시 사용

- bzip2, bunzip2

  블록 정렬 알고리즘과 허브만 부호화를 사용한 압축 프로그램

  gzip보다 압축률은 좋으나 압축 시간이 더 걸림

  ```bash
  bzip2 [option] 파일명 # 압축
  bunzip2 [option] 파일명 # 압축 해제
  
  ## 주요 옵션 ##
  # -d: 압축 해제 시 사용
  # -1: 파일의 압축 시간을 줄임 (압축은 빠르지만 압축률은 떨어짐)
  # -9: 파일을 최대로 압축함 (압축 시간이 늘어남)
  # -c: 결과를 표준 출력으로 보낼 때 사용 (tar와 병행해 작업 시 사용)
  # -f: 존재하는 파일을 덮어씀
  ```

- xz, unxz

  LZMA2 알고리즘을 이용해 만든 데이터 무손실 압축 프로그램

  높은 압축률

  ```bash
  xz [option] 파일명 # 압축
  unxz [option] 파일명 # 압축 해제
  
  ## 주요 옵션 ##
  # -z: 압축 시 사용 (기본 설정이기 때문에 사용하지 않아도 됨)
  # -d: 압축 해제 시 사용
  ```

- zip, unzip

  ```bash
  zip [option] 압축파일명 파일명 # 압축
  unzip 압축파일명 # 압축 해제
  
  ## 주요 옵션 ##
  # -r: 압축 대상이 디렉터리인 경우 하위 디렉터리를 포함하여 압축
  ```

<br>

### gcc

GNU 프로젝트에 의해 만들어진 컴파일러 모음으로 다양한 프로그래밍 언어 지원

리눅스 기반에서 가장 손쉽게 사용할 수 있는 C 컴파일러 도구

```bash
gcc [option] 파일명

## 주요 옵션 ##
# -o: 컴파일할 때 실행 파일의 이름을 지정하는 옵션
# -c: 링크는 하지 않고 목적 파일만 만들어낼 때 사용하는 옵션
```

<br>

### make 유틸리티 활용

make: GNU 프로젝트에 의해 만들어진 프로그램으로 컴파일을 자동화해주는 도구

```bash
make [option]

## 주요 옵션 ##
# -f: Makefile 이외의 다른 파일에서 관련 정보를 참조할 때 사용
```

Makefile의 기본 구조

```bash
목표파일명 : 의존성파일1 의존성파일2...
					  명령행
					  ...
```

실행 시 make 목표파일명 형태로 실행, 첫 번째 목표 파일인 경우 make라고만 입력해도 됨

<br>

## 1.4.3 라이브러리 관리

### 라이브러리의 개요

라이브러리: 프로그램에서 특정한 기능을 하는 루틴들을 모아 놓은 것으로 하나 이상의 서브루틴, 함수, 클래스로 만듦

- 정적 링크 라이브러리: 프로그램 컴파일 시 실행 파일에 포함되어 배포
- 동적 링크 라이브러리: 필요할 때만 라이브러리를 메모리에 적재

<br>

### 공유 라이브러리의 개요

공유 라이브러리: 운영체제에서 많은 응용 프로그램에 동적으로 링크되어 공유되는 라이브러리

<br>

### 공유 라이브러리의 특징

- 의존성: 동적으로 링크된 프로그램은 적어도 하나 이상의 공유 라이브러리가 필요함 만일 필요한 라이브러리가 존재하지 않거나 찾을 수 없으면 프로그램이 실행되지 않음
- 링크: 동적으로 링크된 실행 파일은 실행 시 공유 오브젝트에 대한 동적 링커인 ld.so에 의해 검사됨

<br>

### 공유 라이브러리 관련 디렉터리 및 파일

리눅스에서 사용되는 공유 라이브러리는 파일명 뒤에 .so라고 덧붙여 있음

관련 디렉터리

- /lib: ls, mv와 같은 기본 명령어 및 시스템과 연관된 라이브러리 위치
- /usr/lib: 응용 프로그램과 관련된 라이브러리 위치

특정 디렉터리 위치를 라이브러리 관련 디렉터리로 등록하려면 /etc/ld.so/conf 파일 사용

관련 파일

- /etc/ld.so.conf: 기본적으로 사용되는 공유 디렉터리 이외에 추가로 다른 디렉터리 등록 시 사용하는 환경 설정 파일

  추가 후 `ldconfig` 명령을 수행해 갱신해야 함

- /etc/ld.so.cache: 라이브러리 파일 목록 정보를 담고 있는 파일

<br>

### 공유 라이브러리 관련 명령어

- ldconfig

  공유 라이브러리 관련 정보를 갱신하고 설정하는 명령

  ```bash
  ldconfig [option] [라이브러리]
  
  ## 주요 옵션 ##
  # -p: 현재 캐시에 저장되어 있는 공유 라이브러리 목록 정보 출력
  # -v: 명령 실행과 관련된 자세한 정보 출력
  # -f: /etc/ld.so.conf 파일 대신 다른 환경 설정 파일 지정 시 사용
  ```

- ldd

  특정 파일이나 프로그램이 의존하고 있는 공유 라이브러리 정보 출력

  ```bash
  ldd [option] 파일명
  
  ## 주요 옵션 ##
  # -v: 관련 라이브러리 정보를 버전 등과 함께 자세히 출력
  # -f: /etc/ld.so.conf 파일 대신 다른 환경 설정 파일을 지정할 때 사용
  ```

<br>

### 공유 라이브러리 관련 환경 변수

LD_LIBRARY_PATH: 특정 프로그램 실행 시 라이브러리 등록이 필요한 경우 해당 변수에 디렉터리 경로 등록