# 스프링부트 개념정리 10강 - 서블릿 객체의 생명주기가 궁금해요!
## 서블릿 컨테이너
![image](https://user-images.githubusercontent.com/77559262/154247649-a4e9a664-15cb-4a4d-99e7-9108462d5cf7.png)  
+ 정적인 파일(.html, .css, .png 등) 요청 : 톰켓이 아니라 아파치가 일을 함  
+ 자바 파일 요청 : 톰켓이 일을 함

URL : 자원에 접근하는 방식 (http://naver.com/a.png)   
URI : 식별자를 정해 접근하는 방식 (http://naver.com/picture/a)  
스프링은 URL 방식을 막아 놨기 때문에 식별자를 통해 요청해야 됨 (특정한 파일을 요청할 수 없다, 요청 시에는 무조건 자바를 거쳐야 함)  
→ 스프링은 무조건 톰켓이 일을 함  

요청(java 자원) → 서블릿 컨테이너(톰켓)  
요청을 받으면 하는 일 순서  
1. 서블릿 객체 생성 : new
2. init() 메소드 호출, 기존 스레드 사용
3. service() 메소드 호출 : 요청이 POST/GET/PUT/DELETE 중 무엇인지 확인 (새로운 스레드를 만듦)  
4. 해당 요청에 맞는 메소드 호출 (get(), post() 등)
5. 두 번째로 서블릿 객체를 생성하는 경우 새로 생성하지 않고 재사용 (재사용하면서 새로운 스레드 생성)

java는 new로 객체를 생성하면 heap 영역에 공간을 만듦  
그 후 메소드를 호출하면 stack 영역에 공간을 할당  
이때 해당 메소드가 여러 번 호출되면 각 메소드마다 따로 독립된 공간 생성  

톰켓 기본 설정 : 스레드 Auto (20개, 설정한 개수) → 20개까지의 스레드만 생성, 만약 21번째 요청이 오면 대기  
1번 스레드 response(응답) 시까지 대기한 후 응답이 종료되면 21번째 스레드가 1번 스레드를 재사용 : pooling 기법  

## 서블릿 객체의 생명 주기
1. request 요청
2. 서블릿 객체 생성
3. 메소드 호출
4. 응답
5. 응답이 완료된 스레드는 제거하지 않고 남겨둠 (재사용을 위해) : 풀링 기술

scale-up : 컴퓨터의 성능 업그레이드  
scale-out : 분산 처리
