# 도메인 분석 설계
## 요구사항 분석
어디 있는 값이 바뀔 때 테이블에 업데이트를 할지 결정하는 연관관계 주인이라는 개념을 설정해 주어야 함  
테이블의 경우에는 FK만 바꿔 주면 되는데, 객체에서는 양쪽에 모두 존재하기 때문에 필요한 개념  
FK가 가까운 곳이 연관관계의 주인  
<br>
일대일 관계에서는 FK를 어디에 두든 상관없으나, access를 많이 하는 쪽에 두는 게 좋음   
<br>
엔티티를 변경할 때는 Setter 대신에 변경 지점이 명확한 별도의 비즈니스 메서드를 별도로 제공하는 것이 좋음 (Setter를 다 열어 두면 유지보수에 좋지 않음)  
실무에서는 ManyToMany도 사용하면 안 됨 (운영하기 어렵기 때문에 풀어서 사용하는 것이 좋음)
<br>

## 엔티티 설계 시 주의점
1. 엔티티에는 가급적 Setter를 사용하지 말자  
   변경 포인트가 너무 많아 유지보수 어려움
2. **모든 연관관계는 자연 로딩으로 설정** (fetch = FetchType.EAGER)  
   즉시 로딩(EAGER) : 테이블을 조회할 때 연관된 데이터를 한번에 조회하는 것  
   즉시 로딩은 예측이 어렵고 어떤 SQL이 실행될지 추적하기 어려움  
   모든 연관관계는 지연로딩(LAZY)로 설정해야 함 (@XToOne 관계는 즉시 로딩이 기본이기 때문에 변경해 주어야 함)  
   연관된 엔티티를 함께 조회해야 하는 경우에는 fetch join 또는 엔티티 그래프 기능 사용
3. 컬렉션은 필드에서 초기화하자  
   컬렉션은 필드에서 바로 초기화하는 것이 null 문제에서 안전함  
   하이버데이트가 엔티티를 영속화할 때 컬렉션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경함 따라서 문제가 발생할 확률이 있음  
   생성한 객체를 그대로 두고 바꾸지 않는 것이 안전함
4. 테이블, 컬럼명 생성 전략
    + 스프링 부트 신규 설정(SpringPhysicalNamingStrategy)  
      엔티티 → 테이블  
      카멜 케이스 → 언더스코어   
      점 → 언더스코어  
      대문자 → 소문자  
    + 과거 하이버네이트는 그대로 생성
    + 클래스를 생성하여 커스텀 가능