# 아파치 카프카의 역사와 미래 
## 카프카의 탄생
기존에는 소스 애플리케이션, 타깃 애플리케이션이 하나였기 때문에 그것을 잇는 파이프라인도 하나였음  
소스 애플리케이션, 타깃 애플리케이션의 개수가 많아짐에 따라 그것들을 잇는 파이프라인이 많아지고 복잡해짐  
이때 하나의 애플리케이션에서 장애가 발생하면 그에 관여하는 애플리케이션에 같이 장애가 발생함  

각각의 애플리케이션끼리 연결하여 데이터를 처리하는 것이 아니라 한 곳에 모아 처리할 수 있는 중앙 집중 형식인 Kafka가 개발됨  
<br>

## 카프카 내부 구조
+ 토픽 : RDBMS의 테이블과 같은 개념으로 우리가 데이터를 구분하고자 하는 기준  
+ 프로듀서 : 데이터를 보내는 역할
+ 파티션 : 보낸 데이터가 저장되는 공간으로 데이터가 한 번 전송되면 내부 로직에 따라 여러 파티션 중 하나의 파티션에 적재됨  
파티션의 구조는 큐 구조와 비슷 (FIFO)
+ 컨슈머 : 여러 파티션을 구독하여 데이터를 가져감  
만약 파티션에 있는 데이터를 가져가더라도 데이터가 삭제되지 않음 
    + 커밋 : 각 컨슈머가 데이터를 어디까지 읽었는지 기록하는 것  
<br>

## 카프카가 데이터 파이프라인으로 적합한 이유
1. 높은 처리량 : 카프카는 데이터를 송수신할 때 모두 배치로 묶어서 전송한다. 동일한 양의 데이터를 보낼 때 네트워크 통신 횟수를 최소한으로 줄인다면 비용을 줄일 수 있다. 따라서 카프카는 최소한의 네트워크 비용으로 최대한의 효율을 낼 수 있다.  
또한 파티션 단위를 통해 동일 목적의 데이터를 여러 파티션에 분배하고, 데이터를 병렬 처리할 수 있다. 파티션 개수만큼 컨슈머의 개수를 늘려 동일 시간당 데이터 처리량을 늘리는 것이다.
2. 확장성 : 데이터가 적을 때는 카프카 클러스터의 브로커(데이터를 저장하는 공간)를 최소한의 개수로 운영하다가 데이터가 많아지면 클러스터의 브로커 개수를 늘려 scale-out 할 수 있다. 또한 이에 대한 무중단 운영을 지원한다.
3. 영속성 : 카프카는 다른 메시징 플랫폼과 다르데 전송받은 데이터를 메모리에 저장하지 않고 파일 시스템에 저장한다. 카프카는 운영체제 레벨에서 파일 시스템을 최대한 활용하는 방법을 적용하였다. 페이지 캐시 메모리 영역을 사용하여 한 번 읽은 파일 내용은 메모리에 저장했다가 다시 사용하는 방식을 적용한 것이다. 디스크 기반의 파일 시스템을 활용하여 브로커에 장애가 발생하더라도 데이터를 안전하게 다시 처리할 수 있다.  
___영속성 : 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성___
4. 고가용성 : 카프카 클러스터는 3개 이상의 서버들로 운영되기 때문에 일부 서버에 장애가 발생하더라도 무중단으로 안전하고 지속적으로 데이터를 처리할 수 있다.  
카프카는 데이터의 복제(replication)를 통해 여러 브로커에 전송받은 데이터를 저장하기 때문에 고가용성의 특징을 가진다.  
서버를 직접 운영하는 on-premise 환경의 서버 랙 또는 퍼블릭 클라우드의 리전 단위 장애에도 데이터를 안전하게 복제할 수 있는 브로커 옵션들이 있다.   
<br>

## 빅데이터 아키텍처의 종류
1. 초기 빅데이터 플랫폼 : 원천 데이터, 파생 데이터, 서빙 데이터로 구성  
문제점
    + 엔드 투 엔드 방식으로 데이터를 모으는 구조가 유연하지 못함 
    + 실시간으로 생성되는 데이터들에 대한 인사이트를 서비스 애플리케이션에 빠르게 전달하지 못함
    + 원천 데이터로부터 파생된 데이터의 히스토리를 파악하기 어려움
    + 데이터 가공으로 인해 데이터가 파편화되어 데이터 표준 및 정책을 지키기 어려움

2. 람다 아키텍처 : 배치 레이어, 서빙 레이어, 스피드 레이어로 구성
    + 배치 레이어 : 배치 데이터를 모아 특정 시간, 타이밍마다 일괄 처리
    + 서빙 레이어 : 가공된 데이터를 사용자, 서비스 애플리케이션이 사용할 수 있도록 데이터가 저장된 공간
    + 스피드 레이어 : 서비스에서 생성되는 원천 데이터를 실시간으로 분석하는 용도 (카프카가 위치)  
    + 한계점 : 레이어가 두 개로 나뉘기 때문에 데이터를 분석, 처리하는 로직이 각각의 레이어에 따로 존재해야함 따라서 유연하지 못한 파이프라인이 생성됨

3. 카파 아키텍처 : 람다 아키텍처의 단점 해소를 위해 고안되었으며 스피드 레이어와 서빙 레이어로 구성 모든 배치 데이터를 스피드 레이어에서 처리  
스트림 데이터를 배치로 나타낼 수 있다면 해당 데이터를 기반으로 배치 데이터 처리를 할 수 있는데 이 역할을 카프카가 해줌  
변환 기록 로그에는 timestamp가 같이 저장되어야 특정 시점의 데이터를 묶어서 배치로 저장, 처리할 수 있다.

4. 스트리밍 데이터 레이크 : 카파 아키텍처에서 서빙 레이어를 제거한 형태로 카프카가 스피드 레이어로 모든 레이어를 처리  
이중으로 관리되는 운영 리소스를 줄일 수 있음
<br>

## 배치 데이터와 스트림 데이터
### 배치 데이터
+ 한정된(bounded) 데이터 처리
+ 대규모 배치 데이터를 위한 분산 처리 수행
+ 분, 시간, 일 단위 처리를 위한 지연 발생
+ 복잡한 키 조인 수행 가능, 활용도가 높음
+ 하둡에서 주로 처리하는 방식으로 맵 리듀스 방식으로 처리

### 스트림 데이터
+ 무한(unbounded) 데이터 처리
+ 지속적으로 들어오는 데이터를 위한 분산 처리 수행
+ 분 단위 이하 지연 발생
+ 단순한 키 조인 수행

### 카프카에서 스트림 데이터를 배치로 사용하는 방법
구체화된 뷰(Materialized View)를 통해 특정 일시로 데이터를 뷰 형태로 가져와 한번에 배치처럼 처리