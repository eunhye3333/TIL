# 11. 원시 값과 객체의 비교

| 원시 타입의 값                                               | 객체(참조 타입)의 값                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 변경 불가능                                                  | 변경 가능                                                    |
| 변수에 할당 시 확보된 메모리 공간에 실제 값이 저장           | 변수에 할당 시 확보된 메모리 공간에 참조 값이 저장           |
| 원시 값을 갖는 변수를 다른 변수에 할당 시 원본의 원시 값이 복사되어 전달 (값에 의한 전달) | 다른 변수에 할당 시 원본의 참조 값이 복사되어 전달 (참조에 의한 전달) |

<br>

## 11.1 원시 값

### 11.1.1 변경 불가능한 값

원시 타입의 값은 읽기 전용 값임

원시 값 자체를 변경할 수 없다는 뜻이며 변수 값의 변경과는 관계 없음

해당 특성은 데이터의 신뢰성을 보장함

→ 원시 값이 변경 가능한 경우 예기치 않게 값이 변경된 경우 상태 변경 추적이 어려움

<br>

### 11.1.2 문자열과 불변성

문자열은 0개 이상의 문자열로 이루어져 있기 때문에 몇 개의 문자로 이루어졌는지에 따라 필요한 메모리 공간의 크기가 결정됨

문자열은 유사 배열 객체이면서 이터러블이기 때문에 배열과 유사하게 각 문자에 접근 가능함 하지만 접근하여 변경하는 것은 불가능

<aside> 💡 유사 배열 객체: 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체 원시 값을 객체처럼 사용하면 원시 값을 감싸는 래퍼 객체로 자동 변환됨

</aside>

<br>

### 11.1.3 값에 의한 전달

변수에 원시 값이 복사되어 전달됨

전달된 값은 동일하게 평가되는 값이지만, 다른 메모리 공간에 저장된 별개의 값임

따라서 a 변수에 b 변수의 값을 할당한 후 b 변수의 값을 변경해도 a 변수에는 영향을 미치지 않음

<br>

## 11.2 객체

객체는 프로퍼티의 개수가 정해져 있지 않으며 동적으로 추가, 삭제가 가능하고 프로퍼티의 값에도 제약이 없음

따라서 확보해야 할 메모리 공간의 크기를 사전에 정할 수 없음

자바스크립트는 클래스 없이 객체를 생성할 수 있으며 객체 생성 이후에도 동적으로 프로퍼티와 메서드 추가 가능 → 편리하나 클래스 기반 객체지향 프로그래밍 언어의 객체에 비해 비효율적

따라서 V8 자바스크립트 엔진에서는 프로퍼티에 접근하기 위해 동적 탐색 대신 히든 클래스 방식을 사용해 성능 보장

<br>

### 11.2.1 변경 가능한 값

객체는 변경 가능하기 때문에 메모리에 저장된 객체를 직접 수정할 수 있으며 이때 객체를 할당한 변수의 참조 값은 변하지 않음

객체는 원시 값처럼 일정하지 않기 때문에 복사해서 새로 생성하는 비용이 많이 듦 따라서 메모리를 효율적으로 사용하기 위해 변경 가능하도록 설계됨

이러한 구조적 단점 때문에 여러 개의 식별자가 하나의 객체 공유 가능

<aside> 💡 얕은 복사와 깊은 복사 얕은 복사: 한 단계까지만 복사 깊은 복사: 중첩된 객체까지 모두 복사하여 원시 값처럼 완전한 복사본 생성

</aside>

<br>

### 11.2.2 참조에 의한 전달

원본의 참조 값이 복사되어 전달되는 것

두 개의 식별자가 하나의 객체를 공유하는 형태이기 때문에 원본 또는 사본 중 어느 한쪽에서 객체를 변경하면 서로 영향을 받음